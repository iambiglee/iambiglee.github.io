[{"id":0,"href":"/docs/example/","title":"CatMQ项目文档","section":"Docs","content":" Introduction CatMQ # CatMQ 是一款在参考kafka消息架构基础上发展出来的一款典型的消息队列中间件，使用异步通信的方式和发布订阅模型消息传输队列。 通信方式和传输模型的具体说明可以看下文的通信方式介绍和消息传输模型。 CatMQ具有异步通信的优势，系统拓扑简单，系统间耦合低，主要应用于异步解耦，流量削峰填谷的场景。\n有关CatMQ的功能特性有：\n顺序消息 生产者和消费者的动态缩扩容 消费者和消息队列的动态平衡 支持一个队列被多个消费者组订阅 手动调整消费进度 消息持久化和定期清理 失败消息的保持和重新发送 管理后台网页，可自助运维治理gu "},{"id":1,"href":"/docs/cv/","title":"个人介绍","section":"Docs","content":" CatMq的领域模型 # CatMq 是一款在kafka基础上发展出来的一款典型的消息队列中间件，使用异步通信的方式和发布订阅模型消息传输队列。通信方式和传输模型的具体说明可以看下文的通信方式介绍和消息传输模型。CatMq具有异步通信的优势，系统拓扑简单，系统间耦合低，主要应用于异步解耦，流量削峰填谷的场景。\nCatMq 设计的领域模型 # 消息（Message） # 消费者组（ConsumerGroup） # 消费者（Consumer） # 队列（Queue） # 消息偏移（MessageQueeuOffset） # 消息标签 # 生产者/消费者（product/consumer） # 消息订阅（subscribe） # 服务端（Broke） # 管理端（Portal） # 消息标签(MessageTage) # "},{"id":2,"href":"/docs/example/introduce/","title":"项目介绍","section":"CatMQ项目文档","content":" CatMq的领域模型 # CatMq 是一款在kafka基础上发展出来的一款典型的消息队列中间件，使用异步通信的方式和发布订阅模型消息传输队列。通信方式和传输模型的具体说明可以看下文的通信方式介绍和消息传输模型。CatMq具有异步通信的优势，系统拓扑简单，系统间耦合低，主要应用于异步解耦，流量削峰填谷的场景。\nCatMq 设计的领域模型 # 消息（Message） # 消费者组（ConsumerGroup） # 消费者（Consumer） # 队列（Queue） # 消息偏移（MessageQueeuOffset） # 消息标签 # 生产者/消费者（product/consumer） # 消息订阅（subscribe） # 服务端（Broke） # 管理端（Portal） # 消息标签(MessageTage) # "},{"id":3,"href":"/docs/example/quickstart/","title":"快速开始","section":"CatMQ项目文档","content":" 快速开始 # 本页面将简单介绍一下，如何快速的搭建一个单节点的catmq\n(一)环境准备 # Java 本项目基于JDK1.8+ 开发，启动项目的时候会需要JDK1.8+. 配置好Java以后，可以通过java -version检查java环境，样例输出如下 Java -version Java(TM) SE Runtime Environment (build 1.8.0_74-b02) Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode) Maven 需要安装maven3.0，可以去官网下载最新版本的maven, maven 环境变量设置请参考百度谷歌。配置完成后，打开cmd命令，输入mvn -v,显示下图，表示配置完成。 Maven home: D:\\software\\apache-maven-3.6.2\\bin\\.. Java version: 1.8.0_262, vendor: Red Hat, Inc., runtime: D:\\software\\openjdk-1.8.0.262\\jre Default locale: en_US, platform encoding: GBK OS name: \u0026#34;windows 10\u0026#34;, version: \u0026#34;10.0\u0026#34;, arch: \u0026#34;amd64\u0026#34;, family: \u0026#34;windows\u0026#34; MySQL 版本要求5.7+ 连上MySQL以后，可以通过如下命令检查版本 SHOW VARIABLES WHERE Variable_name = 'version'; Variable_name Value version 5.7.0 CatMQ 需要访问字典表information_schema.tables，来获取表的自增信息，来计算待处理消息等信息。所以需要确保此表能及时更新。 对于mysql 8以上版本推荐查看 show variables like \u0026lsquo;%information_schema_stats%\u0026rsquo;; set global information_schema_stats_expiry=10; 设置字典表的更新时间。\n##（二）安装步骤\n在github上，下载代码到本地，以windows 系统为例，下面所有的项目默认目录为d://catmq. 创建数据库 catmq 需要三种消息库，分别为元数据库，正常消息库和失败消息库。 根据doc/mq_basic.sql创建元数据库，元数据库只有一个（可以设置主备）。根据doc/mq_message_node_01.sql创建正常消息库，根据doc/mq_fail_message_node_01.sql文件创建失败消息库。正常消息库和失败消息库都需要多个（可以根据自己的消息量扩容）。下图是创建的数据库样例，包括：元数据库、两个正常消息库、两个失败消息库。 mq_basic mq_suc mq_fail\n配置数据库信息 catmq默认配置了三种环境的配置信息，fat,uat,pro. 当然用户可以自行通过Spring_active添加配置其他的环境的配置。下面的演示中，默认使用fat 环境，用文本编辑工具打开 d:\\catmq\\mq-ui\\src\\main\\resources\\application-fat.properties d:\\catmq\\mq-rest\\src\\main\\resources\\application-fat.properties 将元数据库的信息配置进去 spring.datasource.url = jdbc:mysql://localhost:3306/mq_basic?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false spring.datasource.username = root spring.datasource.password = root 编译运行 在d://catmq 输入mvn clean install -DskipTests 如果控制台显示success, 则证明编译成功。 默认情况portal占用8089端口，服务端占用8080端口，测试demo占用8087端口。 然后进入 d:\\catmq\\mq-rest\\target 目录下执行 java -jar mq-rest.jar \u0026ndash;spring.profiles.active=fat 启动服务端。\nd:\\mq-cat\\mq-ui\\target 目录下执行 java -jar mq-ui.jar \u0026ndash;spring.profiles.active=fat 启动管理端portal。\n注意：测试demo暂时还不能启动（需要等到消息库初始化完成，并且在portal上手动创建测试程序所需的topic、consumerGroup、订阅关系以后可以启动） 5. 启动验证系统。 在chrome浏览器访问 http://localhost:8080/ 如果出现下图表示CatMQ服务端启动正常。 访问 http://localhost:8090/ 如果出现登录页面，并且可以登录成功，则证明可以正常访问，用户名和密码都是：mqadmin (三)元数据的初始化 # 为了能够启动测试，我们需要初始化一些数据\n初始化消息的存储位置\n启动CatMQ的管理页面(CatMQ-ui模块)，通过账号和密码mqadmin登录系统。然后点击左侧的“DataNode” 点击 \u0026ldquo;Create\u0026rdquo; 跳出的数据库详细信息中，分为主库(master)和从库(slave)，如果没有从库可以不填，数据库是我们上文中提到的mq_suc 的连接信息。 注意：如果“”Database”填写的是正常消息库的名字，则“Store Type”需选择normal（如上图标红所示）。如果“”Database”填写的是失败消息库的名字，则“Store Type”需选择Abnormal。\n点击“提交”，如果看到如下记录，则说明message_node_01这一个节点初始化成功。 (四)客户端的demo显示 # 完成上述步骤以后，我们就可以去CatMQ的mq-client-demo模块中启动该模块 messageQueue.xml文件中定义了ConsumerGroup、Topic、以及它们之间的订阅关系（含义：test1sub订阅了topic：test1和test4）。receiverType指定的是每一个topic的消息处理类。\ndemo就是在项目中的模式是CatMQ 的最小可执行的Example,这里我们已经做好了messageQueue.xml的配置，此次您无需做任何修改\n新建topic\n登录系统管理页面Portal,默认为localhost:8090, 初始化的用户名和密码都为：mqadmin。登录进入以后，点击页面左侧的消息主题管理进入如下画面\n点击“创建”按钮，进入topic 创建界面，然后再“topic名称处”输入testtopic\n点击“提交”完成topic的创建。\n新建ConsumerGroup\n在管理界面，点击左侧的消费者组管理，然后点击“创建”按钮，进入consumeGroup创建界面：\n我们创建一个名为testConsumerGroup的consumerGroup\n创建成功之后，可以看到页面以及创建成功 创建订阅关系 建立consumerGroup和topic的关联,点击上一个画面中的subscribe开始订阅\n点击添加订阅，创建订阅关系\n点击确认，订阅成功 启动客户端的demo,运行程序\n进入 \u0026lsquo;cat-mq-client-test\\target\u0026rsquo; 下面执行 ‘java -jar mq-client-test-001-1.0.0.jar \u0026ndash;spring.profiles.active=fat’ 启动客户端demo 进入‘ConsumerGroupConsumer’, 出现下面的数据表示客户端启动成功,已经成功注册到系统中 测试消息的发送和消息的消费\n在浏览器中的网址栏，或者postman中输入下面的URL地址： http://localhost:8087/test1?topicName=testtopic\u0026amp;count=2 这里表示给Topic: testtopic 发送5条消息 在 catmq-client-test的 log 中会看到 下面的信息表示消息的发送和消费都正常。 常见问题 如果应用无法启用，请检查8080，8087，8087 端口是否被占用。\n"},{"id":4,"href":"/docs/example/concept/","title":"基本概念","section":"CatMQ项目文档","content":" 基本概念介绍 # 本页将主要介绍CatMq 中涉及到的基本概念，以便于用户可以更好的了解本系统\n主题（Topic） # 消息（Message） # 消费者组（ConsumerGroup） # 消费者（Consumer） # 队列（Queue） # 消息偏移（MessageQueeuOffset） # 消息标签 # 生产者/消费者（product/consumer） # 消息订阅（subscribe） # 服务端（Broke） # 管理端（Portal） # 消息标签(MessageTage) # "},{"id":5,"href":"/docs/example/design/","title":"详细设计","section":"CatMQ项目文档","content":" CatMq的领域模型 # CatMq 是一款在kafka基础上发展出来的一款典型的消息队列中间件，使用异步通信的方式和发布订阅模型消息传输队列。通信方式和传输模型的具体说明可以看下文的通信方式介绍和消息传输模型。CatMq具有异步通信的优势，系统拓扑简单，系统间耦合低，主要应用于异步解耦，流量削峰填谷的场景。\nCatMq 设计的领域模型 # 消息（Message） # 消费者组（ConsumerGroup） # 消费者（Consumer） # 队列（Queue） # 消息偏移（MessageQueeuOffset） # 消息标签 # 生产者/消费者（product/consumer） # 消息订阅（subscribe） # 服务端（Broke） # 管理端（Portal） # 消息标签(MessageTage) # "},{"id":6,"href":"/docs/example/deployment/","title":"运维部属","section":"CatMQ项目文档","content":" CatMq的领域模型 # CatMq 是一款在kafka基础上发展出来的一款典型的消息队列中间件，使用异步通信的方式和发布订阅模型消息传输队列。通信方式和传输模型的具体说明可以看下文的通信方式介绍和消息传输模型。CatMq具有异步通信的优势，系统拓扑简单，系统间耦合低，主要应用于异步解耦，流量削峰填谷的场景。\nCatMq 设计的领域模型 # 消息（Message） # 消费者组（ConsumerGroup） # 消费者（Consumer） # 队列（Queue） # 消息偏移（MessageQueeuOffset） # 消息标签 # 生产者/消费者（product/consumer） # 消息订阅（subscribe） # 服务端（Broke） # 管理端（Portal） # 消息标签(MessageTage) # "},{"id":7,"href":"/docs/example/develop/","title":"开发须知","section":"CatMQ项目文档","content":" CatMq的领域模型 # CatMq 是一款在kafka基础上发展出来的一款典型的消息队列中间件，使用异步通信的方式和发布订阅模型消息传输队列。通信方式和传输模型的具体说明可以看下文的通信方式介绍和消息传输模型。CatMq具有异步通信的优势，系统拓扑简单，系统间耦合低，主要应用于异步解耦，流量削峰填谷的场景。\nCatMq 设计的领域模型 # 消息（Message） # 消费者组（ConsumerGroup） # 消费者（Consumer） # 队列（Queue） # 消息偏移（MessageQueeuOffset） # 消息标签 # 生产者/消费者（product/consumer） # 消息订阅（subscribe） # 服务端（Broke） # 管理端（Portal） # 消息标签(MessageTage) # "},{"id":8,"href":"/docs/example/functions/","title":"功能特性","section":"CatMQ项目文档","content":" CatMq的领域模型 # CatMq 是一款在kafka基础上发展出来的一款典型的消息队列中间件，使用异步通信的方式和发布订阅模型消息传输队列。通信方式和传输模型的具体说明可以看下文的通信方式介绍和消息传输模型。CatMq具有异步通信的优势，系统拓扑简单，系统间耦合低，主要应用于异步解耦，流量削峰填谷的场景。\nCatMq 设计的领域模型 # 消息（Message） # 消费者组（ConsumerGroup） # 消费者（Consumer） # 队列（Queue） # 消息偏移（MessageQueeuOffset） # 消息标签 # 生产者/消费者（product/consumer） # 消息订阅（subscribe） # 服务端（Broke） # 管理端（Portal） # 消息标签(MessageTage) # "},{"id":9,"href":"/docs/example/page/","title":"页面操作","section":"CatMQ项目文档","content":" 一、发送模块 # 1.1、创建消息主题（即topic） # 发送方（producer）发消息到指定Topic之前，需要通过catMQ的portal创建该Topic，如果该Topic已存在则无须创建。下面演示一下如何创建Topic，和创建Topic时的注意事项： 点击最下方的“commit”按钮，完成topic的创建，进入如下页面： 图中可以看到我们刚刚创建的topic：testtopic\n点击每条记录最左侧的蓝色图标，可以查看该topic的操作记录。\n创建topic的注意事项：\nTopic的名字不能以“_fail”结尾，因为系统以“_fail”结尾的Topic默认为存储失败消息的topic。 负责人为该Topic的负责人，可以多选。Topic负责人拥有的权限为： 编辑Topic的基本信息。 更改Topic中存储消息的保留天数。 生成和清除该Topic接收消息时的校验Token，修改Token时需慎重。 对该Topic进行扩容，自动扩容时受限于预期每日消息量。 对该Topic对应所有订阅的消费者产生的失败存储Topic的扩容以及更改保留天数。 删除该Topic，注意当存在消费者订阅该Topic的时候，不能删除。 可以在消息查询中查看该Topic中的消息发送的情况。 堆积告警数默认10000，即当待处理消息达到10000时，会向发生堆积的订阅者 发送消息堆积告警。 二、消费模块 # 2.1、创建消费者组（即consumerGroup） # 在“ConsumeGroup”页面，点击“create”按钮，进入“创建消费者组”页面： 注意事项：\n消费者组名字最好以ConsumerGroup结尾，便于识别。 消费者组负责人可以多选，负责人权限为： 编辑该消费者组的基本信息。 消费者组的订阅管理，主要是添加与topic的订阅关系。 强制刷新，刷新broker中内存的该消费者组的订阅关系，便于客户端获得最新的订阅关系。 删除该消费者组。 触发该消费者组的重平衡（即该消费者组下consumer实例的重新分配）。 告警邮箱地址可以多个以英文逗号分隔，告警手机可以多个以英文逗号分隔。 消费机器数为消费的实例数，即启动的应用实例数，主要为了和消息系统2.0相对应。 黑白名单，为了限制哪些机器不可以消费和只可以哪些机器消费，只能选择其中一个。 是否告警，建议当机器消费实例启动后开启。 消息追踪，主要为了追踪消息在消费者中消费情况。 最大实例数用于设置消费者的最大数量，0表示不加限制。 消费模式：CatMQ有三种消费模式，分别是集群模式、广播模式、代理模式。 集群模式：CatMQ最常用的是集群模式（默认的模式）。consumerGroup订阅的topic下的队列会被均匀的分配到我们的消费端实例上（即多个消费端实例共同消费topic中的消息，每个消费端实例只能消费到topic的一部分消息）。 广播模式：每个消费端实例都可以消费到consumerGroup订阅的topic的所有消息（即consumerGroup下的每个消费端实例，都可以消费到全部的消息。并且每个消费端实例所消费的消息完全一样）。 图中可以看到我们刚刚创建的消费者组：test1sub。\n点击每条记录最左侧的蓝色图标，可以查看该consumerGroup的对应操作功能。\n2.2、消费者组订阅管理（即consumerGroup和topic的订阅关系） # 点击上图消费者组test1sub右侧的“订阅管理”按钮，进入到“TestConsumerGroup订阅管理”页面：\n在上图“主题名称”处选择test1sub想要订阅的topic：test1。选择配置参数后，其中注意事项如下：\n重试次数，作用于失败Topic，当消费失败的时候，消息会被发送到失败topic中，另外一个线程会去消费失败Topic中的消息，即进行失败消息的重试，重新消费成功则pass，否则继续重试直到达到最大重试次数。 线程数量，批量消费的线程数量，即同一个队列使用多少个线程去消费，线程数不能超过50。 告警阀值，当消息堆积达到该值时会发送告警邮件。 tag，值消息的标识，设置tag之后，消费者组只能消费这个Topic下带有该Tag的消息。 延迟时间（即延迟处理时间），以毫秒为单位，主要为了满足一些需要延迟去消费的场景，延迟时间最大为259200ms。 拉取条数，是指每次去向broker拉取多少条消息到客户端去消费，相当于一个本地缓存队列，然后本地线程去消费缓存队列里面的消息，批量拉取条数最大为500。 拉取等待时间，设置拉取线程的延迟等待时间。 消费熔断时间，即客户端处理消息的最大消耗时间。超过设置时间则熔断，单位秒,0表示不熔断。 点击“添加订阅”完成订阅，当前页面下方会显示该消费者组订阅的所有Topic，同时也包含了订阅该Topic所产生的失败Topic，如下如所示： 其中注意事项如下：\n其中失败Topic的命名规则为：ConsumerGroupName_TopicName_fail，当添加订阅的时候会创建该失败Topic并默认分配两个队列。（上图中test1sub_test1_fail就是test1sub订阅test1之后生成的失败topic，用于存储失败消息。） 批量拉取条数和批量消费条数需要加以区分，批量拉取条数是每次向broker拉取的条数（例如一次从broker拉取50条消息存储到本地队列），批量消费条数是指每个线程每次去消费的最大条数（例如：一次从本地队列中拿10条消息，做批量入库操作），故会存在，批量拉取条数\u0026gt;=批量消费条数*线程数量 点击编辑按钮，可以设置该消费者订阅该Topic的重试次数、告警阀值、tag、延迟时间、线程数、批量拉取条数、批量消费条数、告警邮件等 点击“Unsubscribe”，解除消费者组和topic的订阅关系。 一个消费者组可以订阅多个topic，注意失败topic是自动生成的，不用单独订阅。 三、管理模块 # 3.1 堆积统计 # CatMQ的portal，登陆之后默认展示“OverStockReport”页面： “堆积统计”页面，用于统计展示consumerGroup的消息堆积情况。\n3.2 数据统计 # “DataReport”用于展示数据节点（即消息数据库节点）的信息。\n注意：消息库中的一张表代表一个消息队列。上表的信息解读为，节点1是储存正常的消息，现在已经分配出去两个队列，还有198条队列没有分配出去\n3.3 队列消费管理 # “队列消费管理页面”用于展示consumerGroup对topic下每一个队列的消费情况，每一条记录对应着一个队列。\n消费端实例（消费者）成功启动之后，消费端实例会订阅一个或者多个相关队列，参数说明如下：\n消费者：又叫消费端实例，根据重平衡策略，consumerGroup订阅的所有topic下的全部队列，会均匀分配给启动的消费端实例。 偏移量：是指当前队列中的消息，被消费到的位置。消息表（即队列）中的id是自增的，所以偏移量就是刚被消费的那条消息的id值。 待处理消息数：未被处理的消息数量，待处理消息数=队列中消息的最大id-当前偏移量。 读写类型：队列的读写类型分为读写和只读。类型为读写时，该队列既可以插入消息又可以消费消息。类型为只读时，该队列只能消费消息，不能插入。注意：这里需要保证一个Topic下至少存在一个可以读写的队列。点击旁边的白色按钮，即可进行读写类型的编辑。 消费标志：队列的消费标志分为正常消费和停止消费。正常消费顾名思义就是该队列的消息能够被正常消费，停止消费则表示该队列中的消息不能被消费，此时消费端不会去拉该队列中的消息。点击旁边的白色按钮，可以进行消费标志的编辑。 消息总数：队列（消息表）中的消息数量，因为我们会定时清理队列中过期的消息，所以消息总数=队列中消息的最大id-队列中消息的最小id，故会存在偏移量大于消息总数的情况。 起始偏移：是指该消费者组订阅该Topic时，该队列中消息的最大id。即消费者组开始消费消息时的位置。 最小id：该队列（消息表）中消息id最小的记录的id。 Topic类型：正常则为存储普通消息的Topic的队列，失败则为存储失败消息的队列，和存储类型对应。 分区id：该条记录对应的队列的id，可以在队列管理中查询到队列相关的信息。 存储类型：是指该队列的存储类型，一般我们使用失败类型的队列储存失败Topic中的消息，正常类型的队列存储正常类型Topic中的数据。 db节点：表示该队列对应于某个数据库中的某张表，消息都是存储在这个表中的，db节点=数据库的域名+数据库的库名+数据库的表名。 “偏移”按钮：管理员可以通过点击“偏移”按钮，来调整消费者在该队列中的消费位置。实时生效，谨慎操作。 3.4 队列管理 # “队列管理”中的每一条记录，代表着一个队列即一张消息表。\n每个队列对应消息数据库中的一张表，可以通过ip+库名+表名定位到具体的哪张表。\n点击每条记录最左侧的蓝色图标，可以查看该queue的操作记录。\n参数说明：\n队列编号：即该队列在queue表中的id。 数据节点编号：该队列（消息表）所属的数据库节点，在db_node表中的id。 ip: 该队列（消息表）所属数据库节点的域名数据库。 数据库名：该队列（消息表）所属数据库节点的名称。 表名：该队列（消息表）对应的表名称。 库状态：该队列（消息表）所属数据库节点的读写类型。读写表示该数据库既可以插入消息又可以拉取消息，只读表示该数据库只能拉取消息，不能插入。 topic：该队列被用于存储那个topic的消息。该字段为空表示:队列还未被分配。 存储类型：正常表示存储普通消息，失败表示存储处理失败的消息。 读写状态：读写表示该队列既可以插入消息，又可以拉取消息。只读表示该队列只能拉取消息，不能插入。 消息总数：队列（消息表）中的消息数量。 最小id：该队列（消息表）中消息id最小的记录的id。 “编辑”按钮：队列没有被分配时，该记录的最右侧可以看到“编辑”按钮，点击“编辑”可以为该队列分配topic。 “设为只读”：队列被分配给某个topic以后，右侧可以看到“设为只读”。点击该按钮可以把当前队列改为只读状态。 “移除”：队列被分配给某个topic以后，右侧可以看到“移除”。点击“移除”，会进入该topic的缩容页面。 例如点击上图中的“移除”按钮，会进入topic：test1的缩容页面： 例如：上图中topic：testtopic拥有两个队列，如果要对testtopic进行缩容，需要先对其中一个队列设置成只读。假设要缩容掉id为1的队列，步骤如下：\n点击id为1的队列右侧的“只读”按钮，把队列设为只读。 点击1右侧的“移除”按钮，完成test1对9173队列的缩容。 3.5 消息查询 # 消息查询主要用于发送方和消费方查看消息，消息查询中具有权限控制：\n作为发送方只能查看到该用户负责的Topic的消息。 作为消费方只能查看到该用户所负责的消费者组中订阅的Topic里面的消息。 消息查询中可以查看正常类型的Topic的消息，也可以查看失败类型的Topic的消息 对于失败类型的Topic中的消息，如果想重新消费，先选择想要重新消费的消息，然后点击“批量重新发送”按钮，则失败消息会重新发送到失败类型的Topic中，便于该消费者重新消费。 3.6 日志查询 # 日志查询页面，用于展示用户操作portal的审计日志： 3.7 消费者查询 # 消费者查询页面，可以根据consumerGroup查询该consumerGroup下的consumer（即消费端实例）。 消费者查询，主要用来查询该消费者组中启动成功的消费端实例：\n其中消费者实例=ip地址+进程号+随机数+端口号。 消费者实例会定期发送心跳给broker，没有心跳的消息者实例会被定时任务清理掉。 3.8 队列报表 # 队列报表，用于统计每个队列中的消息总量、平均每天的消息发送量。\n图片左下角的“全部消息总量”为所有队列中的消息量的和。同理，“平均消息总量”为所有队列每天存入消息的平均值。\n3.9 topic报表 # topic报表，用于监控统计每个topic下的消息量（每个topic下有多个队列即消息表），以及topic下队列分配的合理性。页面如下图所示：\n字段说明：\n消息总量：该topic下所有队列，存储的消息量总和。 实际每日消息量：该topic每天存入的消息量。 每个队列平均每日消息量：topic下每个队列每天存入的消息量。 队列治理：我们根据topic和topic下每个队列的消息总量以及平均消息量，对topic的队列分配数量进行监控统计，分析队列分配的合理性。如果平均消息量过多，会给出“应该扩容”的建议。如果消息量过少，会给出“应该缩容”的建议。 队列数量治理：队列治理的具体值，例如-1表示应该缩容掉一个队列（即减少一个队列），2表示应该扩容两个队列（即增加两个队列），0表示队列分配合理。 操作区：如果topic需要缩容，右侧会展示“缩容”按钮，点击缩容会进入该topic的缩容页面。同理如果topic需要扩容，右侧会展示“扩容”按钮 3.10 物理机报表 # 物理机报表，用于统计展示每台消息库物理机的消息总量、平均每天入库的消息量。 3.11 发送工具 # 为了方便测试人员，我们开发了一个消息发送页面。通过“Simulation Tools”页面，可以简单的实现消息的发送。 四、系统管理员模块 # 注意：以下页面仅对系统管理员展示。\n4.1 数据节点管理 # 数据节点管理，用于消息库节点的创建、编辑、以及创建消息表与元数据库mq_basic中的queue表的对应关系。\n点击“创建”按钮，弹出创建节点的弹框，创建节点时需要注意：\n主库ip和从库ip不能一样。 读写状态：默认为可读可写，表示数据库可以插入也可以查询。 存储类型：选择“正常队列消息”表示该库用于存储普通消息，选择“失败队列消息”表示该库用于存储处理失败的消息。 “批量对比”按钮，用于为所有库节点的消息表创建与queue的对应关系。\n右侧操作区按钮说明：\n编辑：点击“编辑”按钮，可以修改消息库节点的信息。 生成sql:生成创建表的sql语句。 对比：为当前消息库节点的消息表创建与queue的对应关系。 分析：查看该消息库节点下topic的分布情况。 更改状态：修改当前节点的读写状态。 生成insert：生成插入消息库节点记录的sql语句样例（把节点记录插入db_node库中的语句）。 4.2 通知查询 # 通知查询，用于展示重平衡请求记录的信息（表中的每一条记录表示一个重平衡请求），以及重平衡器当前处理到的位置（即重平衡器处理到了第几条请求）。\n通知查询页面包含两张表，图中蓝色标注的表格记录“重平衡器”当前处理到第几条“重平衡请求”（即重平衡器的处理位点）。图中红色标注的表格记录所有重平衡请求（每一条记录都是一个重平衡请求），记录中的消费者组Id就是触发重平衡的consumerGroup的id。\n4.3 lock # CatMQ中有一些定时器，lock页面用于展示定时器与portal实例的对应关系（定时器会被portal实例抢占执行，如果定时器A被portal实例1抢占了，其他的portal实例则抢占不到定时器A了。）\n上图中ip表示的是portal实例的IP地址，key1表示的是不同定时器的名字，具体含义如下：\nmq_auditlog_clean_sk：操作日志清理定时器。 mq_message_clean_sk：消息清理定时器。 mq_noSubscribe_sk：未订阅检查定时器。 mq_redundance_check_sk：冗余检查定时器。 mq_NoActiveConsumer_sk：服务端心跳异常检测定时器（检测心跳异常的客户端）。 mq_queueExpansion_sk：队列空间检查定时器。 mq_notify_clean_sk：清理重平衡请求和缓存更新请求的定时器。 mq_messageLagN_sk：消息堆积检查定时器。 mq_rb_sk：重平衡检查定时器。 4.4 server # server展示的是broker服务端的实例列表。CatMQ的客户端可以通过两种方式去连接broker服务端，第一种是通过域名的方式（通过nginx）,第二种是通过ip直连的方式（客户端会定时拉取broker服务端实例的ip列表，通过ip地址直接访问）。注意：通过ip直连时，需要在server列表中，把可以被访问的broker服务端实例的statusFlag状态位打开（即允许该broker实例接入流量）。\nCatMQ默认采用ip直连的方式（记得去server列表中打开statusFlag状态位）。CatMQ通过配置的方式来实现域名访问和ip直连方式的切换。具体方式如下：\nCatMQ的客户端和服务端分别有一个配置项，都叫做mq.broker.metaMode。 服务端的mq.broker.metaMode默认值为1，表示强制指定为ip直连的方式（此时客户端的mq.broker.metaMode的配置失效）。 如果服务端的mq.broker.metaMode的值设置为-1，表示强制指定为域名访问的方式（此时客户端的mq.broker.metaMode的配置失效）。 如果服务端的mq.broker.metaMode的值设置为0，表示根据客户端的mq.broker.metaMode配置决定访问方式： 客户端的mq.broker.metaMode值默认为true，表示使用ip直连的访问方式。 如果客户端的mq.broker.metaMode值为false，表示使用域名访问的方式。 注意：只有服务端的mq.broker.metaMode值为0时，客户端的mq.broker.metaMode配置才会生效。\n特表说明：发布时为了防止抖动，需要先将待发布的服务端实例关闭，默认30秒同步到客户端，发布完成打开statusFlag状态位。\n4.5 mysql连接数 # 该页面用于展示CatMQ的元数据库和消息库所在物理机的连接数，如下所示：\n上图中物理机表示的是元数据库和消息库的域名。\n4.6 配置列表 # 配置列表，用于展示配置类soaConfig中所有配置的名称、默认值、当前值、以及配置说明，如下图所示：\n4.7 元数据同步 # 元数据同步页面，用于多个环境之间同步topic、consumerGroup、以及订阅关系（即consumerGroup订阅了那几个topic）。\n具体步骤如下：假设我们要把fat环境的元数据同步到uat环境\n同步topic： 首先进入fat环境的“元数据同步”页面，在“请选择同步类型”处选择“同步topic”。 点击生成按钮，fat的界面上会生产成所有topic的json串，复制生成的json串。 然后进入uat环境的“元数据同步”页面，在“请选择同步类型”处选择“同步topic”。把上一步复制的json串，粘贴到uat的文本区域。 点击uat环境中的“同步”按钮，则开始同步。同步完成时会有提示（由于批量同步量比较大，同步过程需要点时间）。 同步consumerGroup： 首先进入fat环境的“元数据同步”页面，在“请选择同步类型”处选择“同步consumerGroup”。 点击生成按钮，fat的界面上会生产成所有consumerGroup的json串，复制生成的json串。 然后进入uat环境的“元数据同步”页面，在“请选择同步类型”处选择“同步consumerGroup”。把上一步复制的json串，粘贴到uat的文本区域。 点击uat环境中的“同步”按钮，则开始同步。同步完成时会有提示（由于批量同步量比较大，同步过程需要点时间）。 同步订阅关系： 首先进入fat环境的“元数据同步”页面，在“请选择同步类型”处选择“同步订阅关系”。 点击生成按钮，fat的界面上会生产成所有订阅关系的json串，复制生成的json串。 然后进入uat环境的“元数据同步”页面，在“请选择同步类型”处选择“同步订阅关系”。把上一步复制的json串，粘贴到uat的文本区域。 点击uat环境中的“同步”按钮，则开始同步。同步完成时会有提示（由于批量同步量比较大，同步过程需要点时间）。 4.8 Statistic # 队列统计report,可以根据实际数据去统计各个使用部门的消息总量的Report。 "},{"id":10,"href":"/docs/example/hidden/","title":"Hidden","section":"CatMQ项目文档","content":" This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); } Fronde cetera dextrae sequens pennis voce muneris # Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "}]