[{"id":0,"href":"/en/docs/example/design/overalldesign/","title":"整体设计","section":"Overall Design","content":" Overall Design # Note: If you are not familiar with distributed queue systems, it is recommended to read the quick start module before diving into the overall design. Hands-on experience in implementing a queue demo will help you better understand the design.\n1. Message Model # The overall message model mainly involves three modules:\nConsumerGroup: Represents a collection of topics and serves as a mechanism for organizing and coordinating consumers in CatMQ. It is subscribed by a group of consumers who collectively consume the topics under this consumer group.\nTopic: A messaging topic in CatMQ, serving as a logical concept for organizing and categorizing messages. Each message belongs to a specific topic, and consumers subscribe to these topics to receive corresponding messages.\nQueue: A container in CatMQ for storing messages, designed as a MySQL table in CatMQ. Each topic can have multiple queues, analogous to partitions in Kafka.\nThe relationships among the three modules are illustrated in the following diagram:\n2. Architecture Model # The architecture modules are shown in the figure below. The descriptions of each module in the figure are as follows:\nBroker\nCatMQ\u0026rsquo;s server, primarily responsible for message delivery, retrieval, and querying, ensuring high availability of messages. Core functionalities include: a. Provide message sending interface b. Provide message retrieval interface c. Dynamic rebalancing of queues and consumer groups d. Metadata synchronization e. Provide synchronization of consumer offsets\nPortal\nCatMQ\u0026rsquo;s management interface, serving as a visualization management console for CatMQ and acting as a NameServer for managing Brokers and routing. Core functionalities include: a. Visualization of ConsumerGroup, topic, and Queue creation and modification b. Management of subscription relationships c. Support for message queries d. Various audit logs and access controls e. Various monitoring reports f. Timers for monitoring system stability\nProducers/Consumers\nCatMQ\u0026rsquo;s producers/consumers, both belonging to the CatMQ client. Core functionalities include: a. Synchronous and asynchronous message sending b. Message retrieval and consumption c. Client heartbeat and offset submission d. Retry and sending of failed messages\nMetadata\nCatMQ\u0026rsquo;s metadata database, used to record the configuration information needed by CatMQ. Core functionalities include: a. Store consumerGroup, topic, and subscription relationships b. Store information about database nodes c. Store allocation relationships for Queue and topic d. Store message offsets\nMessage\nCatMQ\u0026rsquo;s message database, used to persist all messages.\n3. E-R Diagram # DbNode: Records information about the database nodes storing messages, including JDBC URL, username, and password.\nConsumer: Represents the currently active consumers in the system.\nQueue: Records actual allocation information for topics and queues.\nQueueOffset: Records the actual correspondence between consumers and queues, including their consumption offsets (records information about a consumer consuming a specific queue).\nTopic: Consists of multiple queues and is used to store messages.\nConsumerGroup: A collection of topics used to record consumer groups in the system.\nConsumerGroupConsumer: Records the relationships between consumers and consumer groups in the system.\nConsumerGroupTopic: used to record ConsumerGroup and Topic Corresponding relationship "},{"id":1,"href":"/en/docs/cv/","title":"个人介绍","section":"Docs","content":" 个人介绍 # 我是巴熊，一位对java软件工程领域充满热情的软件工程师\n教育背景 # 安徽农业大学 电子信息工程 本科\n技能 # 编程语言：Java ，GO 工具：IDEA, GIT,SVN,CI-CD工具 其他技能：很强的沟通能力，很强的问题解决能力，很强的任务管理能力，很强的产品意识，很强的创新能力，较强的领导力 "},{"id":2,"href":"/en/docs/example/design/serverdesigh/","title":"服务端设计","section":"Overall Design","content":" Server Design # The three core functionalities of CatMQ are message sending, message storage, and message retrieval. The implementation of CatMQ is illustrated in the following diagram:\nThe diagram provides a simple overview of the CatMQ message flow, including sending, storage, and consumption processes.\nNow, let\u0026rsquo;s address four key questions:\nHow does the server store messages in multiple queues for each topic? How do consumers know which queue to pull data from for a specific topic with multiple queues? What is the impact if a consumer fails? What is the impact if a server fails? 1. Message Storage Design # The data flow for message storage on the server is depicted in the following diagram:\nAs shown in the diagram, the process for submitting messages by the producer involves the following steps:\nThe producer sends a request, and load balancing distributes the traffic to a specific broker. Upon receiving the request, the broker distributes messages to queues based on the actual number of queues for Topic A and a counter, using round-robin storage. Load balancing is implemented using a simple setup with Nginx, rather than popular solutions like Dubbo or Spring Eureka. 2. Queue Assignment Design # How does a consumer know which queue to pull data from?\nDuring consumer registration, the server allocates queues to consumers based on the logic shown in the following diagram:\nAs illustrated, the fundamental design is that one consumer can correspond to multiple queues, and one queue can only correspond to one consumer—forming a one-to-many relationship between consumers and queues.\nUpon system startup, when consumers register, the server needs to allocate queues based on the number of consumers in the consumer group and the number of queues subscribed to by the consumer group for all topics. The principle is to balance the relationship between consumers and queues as evenly as possible. The relationship between the consumer group and queues is registered in the queueOffset table. A daemon thread continuously maintains the queueOffset table to ensure real-time accuracy of the data.\nFor example, in the corresponding relationship shown in the diagram, the consumer group has three consumers, and the consumer group has been allocated a total of six queues for subscribed topics. The system\u0026rsquo;s allocation algorithm aims to evenly distribute these six queues among the three consumers.\nDuring normal system operation, if the number of consumers changes or the number of queues for the current topic changes, how does the system ensure the consistency of the relationship between consumers and queues? This is addressed in the next section on re-balancing design.\n3. Re-balancing Design # To address the dynamic changes in the number of consumers and queues, we have a separate design for consumer and queue re-balancing, as shown in the following diagram:\nAs shown in the diagram, the logic for re-balancing is as follows:\nCatMQ has a re-balancer that monitors the addition and removal of consumers, as well as topic expansion and contraction. When changes are detected, the re-balancer triggers re-balancing operations on the affected consumer group. In the diagram, Consumer3 is leaving the consumption. The re-balancer reallocates consumers and queues for the consumer group that needs re-balancing. In the example shown, Queue3 is assigned to Consumer1 for consumption. 4. High Availability Design # As a distributed message queue system, CatMQ is designed for distribution and high availability. For more details, you can refer to the - HA Design.\n"},{"id":3,"href":"/en/docs/example/design/clientdesign/","title":"Client Design","section":"Overall Design","content":" Client Design # When designing the client, following the principles of simplicity and efficiency, I have integrated producers and consumers into the same client. This way, external users only need one client to interact with the Broker.\n1. Consumer Design # In the diagram, \u0026ldquo;Broker\u0026rdquo; represents the CatMQ server module, and \u0026ldquo;Consumer\u0026rdquo; represents the client\u0026rsquo;s consumer module.\nLet\u0026rsquo;s briefly introduce the implementation principle of CatMQ\u0026rsquo;s consumer side:\nPull Consumer Thread: Based on the message offset (QueueOffset, the current consumption position of the consumer), messages are pulled from the Broker to the local consumption queue.\nApplication Consumer Thread: Messages are pulled from the local consumption queue for processing.\nOffset Submission Thread: Periodically submits the current consumption information to the Broker.\nHeartbeat Thread: Periodically reports heartbeat to the Broker.\nFailed Message Retry Thread: Retries consumption of failed messages.\n2. Producer Design # The message sending of the producer is divided into two modes: synchronous and asynchronous.\n2.1. Synchronous Mode # In the diagram, \u0026ldquo;Producer\u0026rdquo; represents the producer, and \u0026ldquo;Broker\u0026rdquo; represents the server.\nThe synchronous mode is a straightforward message storage mode. The producer sends messages to the server, and the server persists the message and returns the result of the persistence.\n2.2. Asynchronous Mode # In the diagram, \u0026ldquo;Producer\u0026rdquo; represents the producer, and \u0026ldquo;Broker\u0026rdquo; represents the server.\nThe asynchronous sending mode increases efficiency by reducing external communication and I/O interactions. It is typically used for less critical message delivery.\nApplication Sending Thread: Messages are first sent to the local buffer queue.\nBatch Sending Thread: Messages from the buffer queue are sent to the broker in batches.\nBroker inserts messages into the database in batches.\n"},{"id":4,"href":"/en/docs/example/design/highavaliable/","title":"High Availability","section":"Overall Design","content":" High Availability Design # Let\u0026rsquo;s provide a simple explanation of the overall high availability design:\nScenario Impact Cause Individual Broker Failure No impact Brokers are stateless, and clients automatically reconnect to other brokers. Individual Message Database Failure No impact Master-slave configuration ensures high availability. Metadata Failure Only affects metadata management functions, no impact on existing production and consumption Clients and management portal cache metadata. Management Portal (Portal) Failure Only affects metadata management functions, no impact on existing production and consumption Clients and management portal cache metadata. Consumer Failure No impact CatMQ\u0026rsquo;s dynamic rebalancing will redistribute consumers and queues. The implementation of CatMQ\u0026rsquo;s high availability is primarily achieved by building a multi-node cluster and using a leader election mechanism to ensure its own high availability. Specifically, the following strategies are employed:\nLeader Election: CatMQ adopts a preemptive leader election approach. If the main master crashes or shows no response for a continuous minute, the system will re-elect a leader to ensure availability. The main master is responsible for synchronizing and updating metadata.\nMaster-Slave Replication: The main node in CatMQ reads or updates metadata from the database. The secondary node only retrieves metadata from the database while ensuring consistency between the metadata obtained by the main and secondary nodes. This way, even if the main node crashes, the new main node can maintain service availability.\nNode Fault Detection: CatMQ uses a heartbeat mechanism for mutual confirmation and status detection. If the main server\u0026rsquo;s heartbeat is not updated within a minute, the cluster will restart the leader election.\nWrite-Ahead Logging (WAL): CatMQ writes its status to the database during leader election and heartbeat detection. Subsequent operations are performed based on this information, allowing the system to continue operations even if the main node crashes.\nSequential Consistency: Each update operation is assigned a globally unique incremental transaction ID, reflecting the occurrence sequence of all transaction operations, ensuring global sequential consistency for all update operations.\nPartitioning: CatMQ divides each topic into multiple partitions. Each partition corresponds to a table in the database, implementing a distributed storage pattern that enhances system concurrency processing capabilities and achieves load balancing.\nReplication: Each partition in CatMQ\u0026rsquo;s database table can be set with a corresponding replication table. This increases data redundancy, improves system fault tolerance, and ensures that services can continue even if a database encounters issues.\nDatabase Cluster: CatMQ\u0026rsquo;s configuration metadata and the real-time correspondence between the server and consumer are stored in the database in real-time. Leveraging mature database clustering solutions in the industry can further enhance system availability.\nThese design and implementation approaches enable CatMQ to achieve high availability and fault tolerance, maintaining service availability even in the face of server failures.\n"},{"id":5,"href":"/en/docs/example/design/trace/","title":"Trace","section":"Overall Design","content":" Design of Tracing # Tracing # For the project\u0026rsquo;s tracing, the internal built-in solution is Meituan\u0026rsquo;s Cat, serving as the project\u0026rsquo;s tracing service. CatMQ\u0026rsquo;s client and server support automatic Cat instrumentation. If your company also uses Cat, simply include cat-client in the pom, and automatic tracing will begin. If Cat is not used, there\u0026rsquo;s no need to worry. If cat-client is not included, CatMQ will not activate Cat instrumentation. Alternatively, you can use Skywalking (may the force be with you) with the javaagent approach for monitoring the trace. For other tracing software, due to resource and time constraints, there is no corresponding testing. Contributions of other tracing solutions are welcome.\nMetrics # For performance monitoring, CatMQ automatically integrates with Metrics. Metrics are mainly used in the project to monitor the quantity of messages. If your company has set up Prometheus, just include the micrometer-registry-Influx dependency in the pom, and the Metrics data can be imported.\n"},{"id":6,"href":"/en/docs/example/introduce/","title":"Introduce","section":"CatMQ Doc","content":" Introduction to CatMQ # CatMQ is a typical message queue middleware developed based on the Kafka messaging architecture. It utilizes asynchronous communication and a publish-subscribe model for message transmission queues. The specifics of the communication method and transmission model are detailed in the following sections.\nCatMQ boasts the advantages of asynchronous communication, a simple system topology, and low coupling between systems. It is primarily used in scenarios requiring asynchronous decoupling and smoothing of traffic peaks and valleys.\nKey features of CatMQ include:\nSequential Messaging Dynamic scaling of producers and consumers Dynamic balance between consumers and message queues Support for a queue being subscribed to by multiple consumer groups Manual adjustment of consumption progress Message persistence and periodic cleaning Retention and retransmission of failed messages Web-based management console for self-service operation and maintenance For a detailed introduction to the features, you can refer to - Functions\n"},{"id":7,"href":"/en/docs/example/quickstart/","title":"Quick Start","section":"CatMQ Doc","content":" Quick Start # This page will provide a brief guide on how to quickly set up a single-node CatMQ instance.\n(I) Environment Setup # Java This project is developed based on JDK 1.8 or later. You will need JDK 1.8 or later to run the project. After configuring Java, you can check the Java environment using the java -version command. Sample output:\njava -version Java(TM) SE Runtime Environment (build 1.8.0_74-b02) Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode) Maven Maven 3.0 or later is required. You can download the latest version from the official website. After installing Maven, check the configuration by opening the command prompt and entering mvn -v. If the configuration is correct, you will see output similar to the following:\nMaven home: D:\\software\\apache-maven-3.6.2\\bin\\.. Java version: 1.8.0_262, vendor: Red Hat, Inc., runtime: D:\\software\\openjdk-1.8.0.262\\jre Default locale: en_US, platform encoding: GBK OS name: \u0026#34;windows 10\u0026#34;, version: \u0026#34;10.0\u0026#34;, arch: \u0026#34;amd64\u0026#34;, family: \u0026#34;windows\u0026#34; MySQL Version 5.7 or later is required. After connecting to MySQL, you can check the version using the following command: SHOW VARIABLES WHERE Variable_name = 'version';\nVariable_name Value version 5.7.0 CatMQ needs to access the information_schema.tables dictionary table to retrieve information about table increments for calculating pending messages and other information. Ensure that this table is promptly updated. For MySQL 8 and above, it is recommended to check show variables like '%information_schema_stats%'; set global information_schema_stats_expiry=10; to set the update time for the dictionary table.\n(II) Installation Steps # Download the code from GitHub to your local machine. For this example, let\u0026rsquo;s assume the project directory is d://catmq.\nCreate Databases: CatMQ requires three types of databases: metadata database, normal message database, and failed message database. Create the databases as follows:\nExecute the doc/mq_basic.sql script to create the metadata database (only one needed, can set up master and standby). Execute the doc/mq_message_node_01.sql script to create the normal message database. Execute the doc/mq_fail_message_node_01.sql script to create the failed message database. Here\u0026rsquo;s an example of the created databases: mq_basic, mq_suc, and mq_fail.\nConfigure Database Information: CatMQ comes with default configurations for three environments: fat, uat, and pro. Users can add configurations for other environments by setting Spring_active. In the following demonstration, we will use the fat environment. Open the following files with a text editor:\nd://catmq/mq-ui/src/main/resources/application-fat.properties d://catmq/mq-rest/src/main/resources/application-fat.properties Add the metadata database information:\nspring.datasource.url = jdbc:mysql://localhost:3306/mq_basic?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false spring.datasource.username = root spring.datasource.password = root Compile and Run: Open the command prompt in d://catmq and run mvn clean install -DskipTests. If the console displays \u0026ldquo;success,\u0026rdquo; the compilation is successful. By default, the portal uses port 8089, the server uses port 8080, and the test demo uses port 8087. Then navigate to:\nGo to the d://catmq/mq-rest/target directory and run the following command to start the server: java -jar mq-rest.jar --spring.profiles.active=fat Go to the d://catmq/mq-ui/target directory and run the following command to start the portal: java -jar mq-ui.jar --spring.profiles.active=fat Note: The test demo cannot be started immediately (you need to wait for the initialization of the message database and manually create the necessary topics, consumer groups, and subscription relationships on the portal).\nVerify System Startup: Open Google Chrome and visit http://localhost:8080/. If the page appears as shown below, the CatMQ server has started successfully. Visit http://localhost:8090/. If the login page appears and you can log in successfully, it means the portal is accessible. The username and password are both mqadmin. (III) Metadata Initialization # To run tests, we need to initialize some data.\nInitialize the storage location for messages:\nStart CatMQ\u0026rsquo;s management page (CatMQ-ui module). Log in to the system with the account and password mqadmin. Then click on \u0026ldquo;DataNode.\u0026rdquo; Click on \u0026ldquo;Create.\u0026rdquo; In the detailed database information that pops up, there are main database (master) and secondary database (slave) sections. If there is no secondary database, you can leave it empty. The database is the connection information for mq_suc mentioned in the previous section.\nNote: If the \u0026ldquo;Database\u0026rdquo; is filled in with the name of the normal message database, the \u0026ldquo;Store Type\u0026rdquo; should be selected as normal (as indicated in the red box in the figure). If the \u0026ldquo;Database\u0026rdquo; is filled in with the name of the failed message database, the \u0026ldquo;Store Type\u0026rdquo; should be selected as Abnormal.\nClick \u0026ldquo;Submit.\u0026rdquo; If you see the record as shown below, it means the initialization of the message_node_01 node was successful. (IV) Display of Client Demo # After completing the above steps, you can go to the mq-client-demo module of CatMQ and start this module. The messageQueue.xml file defines the ConsumerGroup, Topic, and their subscription relationships (meaning: test1sub subscribes to the topics test1 and test4). The receiverType specifies the message processing class for each topic.\nThe demo is the smallest executable example of CatMQ in the project. Here, we have configured the messageQueue.xml, so you don\u0026rsquo;t need to make any modifications.\nCreate a topic\nLog in to the system management page (Portal), which is by default at localhost:8090. The initialized username and password are both mqadmin. After logging in, click on \u0026ldquo;Message Topic Management\u0026rdquo; on the left side to enter the following page: Click the \u0026ldquo;Create\u0026rdquo; button to enter the topic creation page. Then enter \u0026ldquo;testtopic\u0026rdquo; in the \u0026ldquo;Topic Name\u0026rdquo; field. Click \u0026ldquo;Submit\u0026rdquo; to complete the creation of the topic.\nCreate a ConsumerGroup\nOn the management page, click on \u0026ldquo;Consumer Group Management\u0026rdquo; on the left side, then click the \u0026ldquo;Create\u0026rdquo; button to enter the consumerGroup creation page: We create a consumerGroup named testConsumerGroup. After successfully creating it, you can see the success message on the page. Create a subscription relationship\nEstablish the association between the consumerGroup and the topic. Click \u0026ldquo;subscribe\u0026rdquo; on the previous page to start subscribing: Click \u0026ldquo;Add Subscription\u0026rdquo; to create a subscription relationship: Click \u0026ldquo;Confirm,\u0026rdquo; and the subscription is successful: Start the client demo; run the program:\nGo to \u0026lsquo;cat-mq-client-test\\target\u0026rsquo; and execute \u0026lsquo;java -jar mq-client-test-001-1.0.0.jar \u0026ndash;spring.profiles.active=fat\u0026rsquo; to start the client demo. Go to \u0026lsquo;ConsumerGroupConsumer,\u0026rsquo; and if you see the following data, it means the client has started successfully and has been registered in the system: Test message sending and consumption:\nIn the browser\u0026rsquo;s address bar or in Postman, enter the following URL: http://localhost:8087/test1?topicName=testtopic\u0026amp;count=2. This means sending 2 messages to Topic: testtopic. In the log of catmq-client-test, you will see the following information, indicating that message sending and consumption are both normal: Common Issues: If the application cannot start, check if ports 8080, 8087, 8087 are occupied.\n"},{"id":8,"href":"/en/docs/example/concept/","title":"Concept","section":"CatMQ Doc","content":" Introduction to Basic Concepts # This page will introduce the fundamental concepts involved in CatMQ to help users understand CatMQ better.\nTopic # A topic represents an aggregation of a certain type of message, used to distinguish different business messages. The relationship between topics and messages is one-to-many logic, and it is the smallest unit of message subscription in CatMQ.\nIn topic-based systems, messages are published to topics or named channels. Consumers receive all messages on the topics they subscribe to, and producers define the categories of messages subscribers subscribe to. This is a basic conceptual model, and in actual applications, the structure can be more complex. For example, to support high concurrency and horizontal scaling, the intermediate message topics need to be partitioned. The same topic may have multiple producers, and the same message may have multiple consumers, with load balancing between consumers.\nMessage # A message is the smallest unit of data transfer in CatMQ. Producers wrap business data into messages and send them to the server. The server delivers messages to consumers for consumption according to the relevant semantics.\nConsumer Group # A consumer group is an abstract concept with multiple consumers under it. A consumer group collectively subscribes to a topic. Messages are dynamically allocated to different consumers based on a set algorithm, enhancing system fault tolerance and scalability.\nProducer/Consumer # Producers are responsible for producing messages, typically managed by the business side. Message producers send messages to the server (Broker) of the message system. Consumers are responsible for consuming messages, usually downstream businesses, retrieving messages from the server of the consumption system.\nQueue # A queue is where messages are actually stored, and it is the smallest unit of message storage. All topics in CatMQ are composed of multiple queues.\nMessage Offset (MessageQueueOffset) # Message offset records the position of a message in the queue. Since the system persists information, old messages do not disappear after consumption. The system automatically records the latest message consumption position, and the next time messages are consumed, they start from this offset.\nMessage Tag (MessageTag) # Message tags are fine-grained consumption classification attributes provided by CatMQ. Consumers can control messages more finely based on MessageType.\nMessage Subscription (Subscribe) # Message subscription is the rule and status configuration for consumers to receive and process messages. After subscribing to a topic, messages from that topic will be sent to the consumer.\nBroker # The basic operational unit of CatMQ, a stateless entity that can easily scale horizontally, go online, or offline.\nPortal # The front-end operational management interface of CatMQ. Through visual operations, access control, and other functions, users can easily and intuitively manage the metadata information of CatMQ.\n"},{"id":9,"href":"/en/docs/example/design/","title":"Overall Design","section":"CatMQ Doc","content":" Overall Design # Note: If you are not familiar with distributed queue systems, it is recommended to read the quick start module before diving into the overall design. Hands-on experience in implementing a queue demo will help you better understand the design.\n1. Message Model # The overall message model mainly involves three modules:\nConsumerGroup: Represents a collection of topics and serves as a mechanism for organizing and coordinating consumers in CatMQ. It is subscribed by a group of consumers who collectively consume the topics under this consumer group.\nTopic: A messaging topic in CatMQ, serving as a logical concept for organizing and categorizing messages. Each message belongs to a specific topic, and consumers subscribe to these topics to receive corresponding messages.\nQueue: A container in CatMQ for storing messages, designed as a MySQL table in CatMQ. Each topic can have multiple queues, analogous to partitions in Kafka.\nThe relationships among the three modules are illustrated in the following diagram:\n2. Architecture Model # The architecture modules are shown in the figure below. The descriptions of each module in the figure are as follows:\nBroker\nCatMQ\u0026rsquo;s server, primarily responsible for message delivery, retrieval, and querying, ensuring high availability of messages. Core functionalities include: a. Provide message sending interface b. Provide message retrieval interface c. Dynamic rebalancing of queues and consumer groups d. Metadata synchronization e. Provide synchronization of consumer offsets\nPortal\nCatMQ\u0026rsquo;s management interface, serving as a visualization management console for CatMQ and acting as a NameServer for managing Brokers and routing. Core functionalities include: a. Visualization of ConsumerGroup, topic, and Queue creation and modification b. Management of subscription relationships c. Support for message queries d. Various audit logs and access controls e. Various monitoring reports f. Timers for monitoring system stability\nProducers/Consumers\nCatMQ\u0026rsquo;s producers/consumers, both belonging to the CatMQ client. Core functionalities include: a. Synchronous and asynchronous message sending b. Message retrieval and consumption c. Client heartbeat and offset submission d. Retry and sending of failed messages\nMetadata\nCatMQ\u0026rsquo;s metadata database, used to record the configuration information needed by CatMQ. Core functionalities include: a. Store consumerGroup, topic, and subscription relationships b. Store information about database nodes c. Store allocation relationships for Queue and topic d. Store message offsets\nMessage\nCatMQ\u0026rsquo;s message database, used to persist all messages.\n3. E-R Diagram # DbNode: Records information about the database nodes storing messages, including JDBC URL, username, and password.\nConsumer: Represents the currently active consumers in the system.\nQueue: Records actual allocation information for topics and queues.\nQueueOffset: Records the actual correspondence between consumers and queues, including their consumption offsets (records information about a consumer consuming a specific queue).\nTopic: Consists of multiple queues and is used to store messages.\nConsumerGroup: A collection of topics used to record consumer groups in the system.\nConsumerGroupConsumer: Records the relationships between consumers and consumer groups in the system.\nConsumerGroupTopic: used to record ConsumerGroup and Topic Corresponding relationship "},{"id":10,"href":"/en/docs/example/deployment/","title":"运维部属","section":"CatMQ Doc","content":" 部署文档 # 单机部署 # 单机部署可以参考另一篇文章Quickstart。\n快速开始 分布式部署 # CatMQ 服务端需要部署的两个包是CatMQ-rest （server端）和CatMQ-ui(portal端), 并且server端和portal端都是无状态，并且内部自制了简单 的服务发现功能，所以可以在不搭配其他的分布式组件的形式下使用和发布。 只需要在\\catmq-rest\\src\\main\\resources 和 \\catmq-ui\\src\\main\\resources 下添加对应的环境配置即可，例如添加fat环境， 只需要在上面对应的目录中添加application-fat.properties 文件即可，对应的配置项跟其他环境一样，只是值可能不同。 CatMQ中自制的服务发现功能，将各个server端和portal端的状态信息都存在数据库中，并且每隔5秒钟注册心跳，所以只要server端和portal端成功链接上 数据库即可自动服务发现。这种方案也可以结合Eureka , nginx, nacos 等服务发现的组件。 CatMQ 分布式部署重点在于数据库的集群部署，建议使用主从数据库的方式部署元数据库（1主2从），并且交由infrastructure 运维团队运维。确保元数据 正常使用. 部署的架构图如下所示：\n"},{"id":11,"href":"/en/docs/example/develop/","title":"开发须知","section":"CatMQ Doc","content":" CatMQ develop guide # This module mainly introduces the code structure and project modules of the project, which is a convenient reference for students who plan to study this project carefully and those who want to develop it again.\n1. Module Structure # mq-client\\mq-core mq-core is the most basic module in catMQ, as it name,which contains the most basic dto objects and public methods. The basis for all projects mq-biz mq-biz is the business logic processing layer, service and server-side broker and page operation and maintenance-side portal, which contains database entities and many scheduled polling threads, used by mq-rest module and mq-ui module mq-rest mq-rest is the broker server of catMQ, which is used to provide rest services to clients. It mainly provides message sending, message pulling, heartbeat requests, and rebalancing. mq-ui catMQ\u0026rsquo;s portal interface provides users with a visual operation and maintenance interface. mq-client\\mq-client-core The core of the client, does not rely on third-party jar packages except for the http, and encapsulates the client\u0026rsquo;s interface. mq-client\\mq-client-spring mq-client-core is encapsulated in spring to simplify operations and provides some service statistics interfaces mq-client\\mq-clent-springboot mq-client-core springboot start module mq-client-test catMQ client demo 2. Local Develop Environment # In application.properties config file default set spring.profiles.active=fat，set as fat。 and the jdbc connection is in application.properties too，there are two modules that require database configuration connection are mq-rest and mq-ui. 3. Start in IDEA # To locally start the application, you need to launch two services. Click on \u0026lsquo;Debug\u0026rsquo; for \u0026lsquo;RestApplication\u0026rsquo; to start mq-rest. Then click on \u0026lsquo;Debug\u0026rsquo; for \u0026lsquo;UiApplication\u0026rsquo; to start mq-ui, as shown in the following screenshot:\u0026quot; "},{"id":12,"href":"/en/docs/example/functions/","title":"Functions","section":"CatMQ Doc","content":" Function Features # Sequential Messaging # Sequential messaging is one of the key messaging features supported by CatMQ. Sequential messaging follows a FIFO (First In, First Out) model, where messages sent earlier are consumed first. CatMQ ensures that messages within a Consumer Group are consumed in order. If a message consumption fails, CatMQ will attempt to retry consuming the failed message. Only after the specified number of failed retries will it move on to the next message.\nDelayed Messaging # Delayed messaging is primarily designed to meet the needs of scenarios requiring delayed consumption. The unit for setting delayed messaging is in seconds. When different consumer groups subscribe to the same topic, you can set different delay times for these consumer groups.\nLoad Balancing for Consumers and Queues # CatMQ allows dynamic addition or removal of consumers and actual message queues to handle situations where there is either too much accumulation of consumption or unexpected crashes of some consumers within a group. CatMQ dynamically re-matches the relationship between consumers and queues. Note that if the current number of consumers is greater than or equal to the number of queues, simply adding more consumers will not trigger re-balancing.\nSupport for One Queue Subscribed by Multiple Consumer Groups # CatMQ supports a queue being simultaneously subscribed to by multiple consumer groups. The consumption of the queue by one consumer group does not affect the consumption status of another consumer group. For example, if consumer groups A and B both subscribe to queue C, any changes in consumer group B will not impact the consumption status of consumer group A.\nConsumer Progress Adjustment # CatMQ supports real-time dynamic adjustment of the consumption progress for consumer groups. The adjustment takes effect immediately, and all consumers will start consuming from the new consumption offset. Of course, the new consumption offset must be less than the current maximum consumption ID of the message queue. If forcibly set to a new consumption offset greater than the maximum ID of the message queue, it will be automatically reset to the maximum ID.\nMessage Storage and Scheduled Cleanup # CatMQ uses a database to persist messages, and the database structure design can be referenced in /doc/db. To prevent excessive redundant data causing data overflow, queues are created with a default message expiration time. Once the message expiration time is reached, messages are automatically cleared.\nSelf-Service Operations and Governance # CatMQ features a self-service governance administration console where users can create and manage all topics, consumer groups, and consumer offsets. It supports self-service creation and scaling of queues and facilitates self-management of relationships between Consumer Groups and Queues.\n"}]