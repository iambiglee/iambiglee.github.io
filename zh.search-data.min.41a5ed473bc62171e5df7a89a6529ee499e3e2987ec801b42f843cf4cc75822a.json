[{"id":0,"href":"/docs/example/design/overalldesign/","title":"整体设计","section":"整体设计","content":" 整体设计 # 小提示：如果你不是很了解分布式队列系统，了解整体设计之前，可以先阅读一下quick start模块，动手实现一个队列 demo，会有助于你更好的了解整体的设计\n1. 消息模型 # 消息的整体模型主要涉及到三个模块\nConsumerGroup表示一些topic的集合，是 CatMQ组织和协调消费者们的一种机制，会被一组消费者订阅，这组消费者会共同消费这个消费者组下面的 topic。\nTopicTopic 是 CatMQ中的消息主题，是一种逻辑概念用来组织和分类消息，没个消息都属于一个特定的主题，而消费者们也会通过订阅这些 topic来接受对应的消息。\nQueueQueue 是 CatMQ 中存储消息的容器，在 CatMQ 中被设计为一张 MySQL的数据表，每个主题可以有多个 Queue, 可以类比为 Kafka 中的partition.\n三种之间的关系如下图所示{width=\u0026ldquo;6.6851859142607175in\u0026rdquo; height=\u0026ldquo;3.8367104111986in\u0026rdquo;}\n2. 架构模块 # 架构模块如下图所示，图中各个模块的说明如下{width=\u0026ldquo;6.8518525809273845in\u0026rdquo; height=\u0026ldquo;3.8025754593175853in\u0026rdquo;}\nBroker\nCatMQ的服务端，主要负责消息的投递，拉取和查询，保证消息的高可用。核心功能如下 a. 提供消息发送接口\nb. 提供消息拉取接口\nc. 提供队列和消费者组的动态重平衡\nd. 元数据的同步\ne. 提供消费偏移的同步\nPortal\nCatMQ的管理界面，主要提供一个CatMQ的可视化管理后台以及作为NameServer,做到Broker 和路由的管理。核心功能如下：\na. ConsumerGroup,topic,Queue的可视化创建和修改\nb. 管理订阅关系\nc. 支持消息查询\nd. 各种审计日志和权限控制\ne. 各种监控报表\nf. 一些监控系统稳定性的定时器\nProducers/Consumers\nCatMQ的生产者/消费者，同属于CatMQ客户端下面，核心功能有\na. 消息同步和异步发送\nb. 消息拉去和消费\nc. 客户端的心跳和偏移的提交\nd. 失败消息重试和发送\nMetadata\nCatMQ的元数据库，用来记录CatMQ所需要的配置信息，核心功能有：\na. 储存consumerGroup,topic 以及订阅关系\nb. 储存数据库的节点信息\nc. 储存Queue,topic,的分配关系\nd. 储存消息偏移\nMessage\nCatMQ的消息数据库，用来持久化所有的消息\n3. E-R图 # DbNode: 记录存储消息的数据库的节点信息，包括 jdbcurl , 用户名，密码\nConsumer：当前系统活跃的消费者\nQueue: 记录 topic 和队列表的实际分配的信息\nQueueOffset: 记录 consumer 和 Queue 的实际对应关系，并且记录他们的消费偏移，（记录某个消费者消费某条 queue的信息）\nTopic: 多个 Queue, 用来存储消息\nConsumerGroup: topic的集合，用来记录系统中的 consumerGroup\nConsumerGroupConsumer: 用来记录系统中的 Consuemr 和 ConsumerGroup 对应的关系\nConsumerGroupTopic: 用来记录 ConsumerGroup 和 Topic 对应的关系{width=\u0026ldquo;5.0in\u0026rdquo; height=\u0026ldquo;3.7in\u0026rdquo;}\n"},{"id":1,"href":"/docs/example/design/serverdesigh/","title":"服务端设计","section":"整体设计","content":" 服务端设计 # CatMQ最核心的三个功能为：消息发送，消费储存，消息拉取, CatMQ实现方法如下图所示:\n上图简单描述了CatMQ消息的发送，储存，消费流程。\n下面将重点解决四个问题\n每个topic有多个Queue,服务端是如何将消息存到某个Queue中去的\n每个topic有多个Queue,消费端是怎么知道去哪个Queue中去拉取数据的\n如果某个consumer挂掉了，会对系统有什么影响\n如果某个服务端挂掉了，会有什么影响\n1. 消息存储设计 # 服务端储存消息的数据流转图如下\n如上图所示，producer 提交信息的流程如下\nProducer发送请求，通过负载均衡将流量分发到一台broker上面\nbroker收到请求之后，会根据实际的TopicA队列的数量和计数器，对queue进行轮训储存\n负载均衡并没有使用比较流行的 dubbo和 spring Eureka.简易配合 nginx 使用\n2. 队列分配设计 # consumer是怎么知道自己应该拉取哪个Queue的消息呢？\n在consumer注册的时候，服务端会对consumer 进行队列分配，分配的逻辑如下图\n如图所示，最基本的设计是，一个consumer可以对应多个Queue, 一个Queue只能对应一个consumer, consumer 和 Queue是一对多的关系。\n系统在启动的时候，如果有consumer注册进来，服务端要根据consumerGroup下面的consumer数量，consumerGroup订阅的所有的topic的队列数量进行队列分配。原则是尽量的平衡分配consumer 和Queue的关系。consuemrGroup和Queue的分配的关系会登记在queueOffset表中，并且有一个守护线程一直在轮训维护queueOffset表，确保数据的实时准确性。\n例如上图的对应关系中，consumerGroup中有三个consumer,consumerGroup订阅的topic一共分配了6个Queue。那么系统的分配算法就是平均的将这六个Queue 平均的分给三个消费者。\n那如果在系统正常运行的时候，如果consumer的数量出现变化，或者当前Topic 下面Queue 的数量出现变化，系统是如何确保消费者和队列的对应关系的呢？请看下文的重平衡设计\n3. 重平衡设计 # 为了解决consuemr和Queue数量动态变化的时候，出现实时情况和QueueOffset表记录不一致的问题，我们单独做出一个消费者和队列的重平衡设计，设计图如下\n如上图所示，重平衡的逻辑如下\nCatMQ有一个重平衡器，它用来监控consumer的加入和退出，topic扩容和缩容\n当监控到第一步的出现数据变化的时候，就回触发重平衡对这个consumerGroup进行重平衡操作,上图中是 Consumer3 退出消费\n重平衡器对需要重平衡的consumerGroup,进行consumer和Queue进行重新分配，将 Queue3 交给 Consumer1 消费\n4. 高可用设计 # 作为一个分布式消息队列系统，我是怎么设计的分布式和高可用的呢？ 具体可以参考： - HA Design\n"},{"id":2,"href":"/docs/cv/","title":"个人介绍","section":"Docs","content":" 个人介绍 # 我是巴熊，一位对java软件工程领域充满热情的软件工程师\n教育背景 # 安徽农业大学 电子信息工程 本科\n技能 # 编程语言：Java ，GO 工具：IDEA, GIT,SVN,CI-CD工具 其他技能：很强的沟通能力，很强的问题解决能力，很强的任务管理能力，很强的产品意识，很强的创新能力，较强的领导力 "},{"id":3,"href":"/docs/example/design/clientdesign/","title":"客户端设计","section":"整体设计","content":" 客户端设计 # 设计客户端的时候，本着简单高效的原则，我将生产者和消费者的放在同一个客户端，这样外部用户在使用的时候，只需要一个client 就可以达到和Broker交互的目的。\n1. 消费端设计 # 图中的Broker 表示catMQ的服务端模块，消费者表示的是客户端的消费者模块。\n我们简单介绍一下catMQ的消费端实现原理\n拉消费线程：根据消息偏移（QueueOffset,消费者当前消费到的位置）,从Broker拉取消息到本地的消费队列。\n应用消费线程：从本地消费队列中拉取消息，进行消费\n偏移提交线程：定时提交当前的消费信息到Broker\n心跳线程：定时上报心跳到Broker\n失败消息重试线程：对失败的消息进行重试消费\n2. 生产者设计 # 生产者的消息发送分为两种模式，同步模式和异步模式\n2.1. 同步模式 # 上图中的Producer表示生产者，Broker表示服务端\n同步模式是一个很简单的消息存储模式，生产者将消息发送到服务端，服务端将消息持久化并且返回持久化结果\n2.2. 异步模式 # 上图中的Producer表示生产者，Broker表示服务端\n异步的发送模式通过减少外部通信，io交互的方式完成提高效率，通常用于一些不重要的消息传递\n应用发送线程：先将消息发送到本地的缓冲队列。\n批量发送线程：把缓冲队列的消息批量发送到broker。\nbroker将消息批量插入到数据库中。\n"},{"id":4,"href":"/docs/example/design/highavaliable/","title":"高可用设计","section":"整体设计","content":" 高可用设计 # 先对整体的高可用做一个简单的表单说明\n场景 影响 原因 个别Broker挂机 无影响 Broker无状态，客户端会自动重连到其他broker 个别消息数据库挂机 无影响 主从保证高可用 元数据挂机 仅影响元数据的管理功能，现有的生产消费无影响 客户端和管理端会缓存元数据 管理端Portal挂机 仅影响元数据的管理功能，现有的生产消费无影响 客户端和管理端会缓存元数据 消费者挂机 无影响 catMQ的动态重平衡会重新分配消费者和队列 CatMQ高可用的实现方式，主要是通过构建多节点集群，利用抢占锁选主的方式，来保证自身的高可用性。具体来说，主要是通过下面几种方式和策略：\n抢占式选主， CatMQ 的选主采取的是抢占式式选主，如果主master宕机，或者连续一分钟没有反应， 系统会重新进行选主，确保系统可用。主master负责同步元数据和更新元数据 主从复制 CatMQ主节点会从数据库读取获取元数据或者更新元数据，从节点只会从数据库获取元数据，同时会确保主节点和从节点获取的元数据一致，这样即使主节点 宕机，新的主节点依旧可以保持服务可用。 节点故障检测 CatMQ 通过心跳机制来互相确认检测状态，一旦主服务器心跳没有在1分钟内更新，会重新启动集群选主。 写操作日志（Write-Ahead Logging，WAL） CatMQ在进行选主，心跳检测的时候，都会将自己的状态写入数据库中，然后再进行后续的操作，这样即使主节点发送崩溃，后续操作都可以继续进行。 顺序一致性 每次更新操作都分配一个全局唯一的递增的事务id，这个id 体现了所有事务操作的发生顺序，从而保证了所有的更新操作的全局顺序一致性。 分区 CatMQ 将每个主题（Topic）划分为多个分区（Partition）。每一个分区都对应数据库的一张表，这就实现了一种数据分布式存储的模式， 增加了系统的并发处理能力，也实现了负载均衡。 副本 CatMQ的每一个分区对应的数据库的表，都可以设置一个从数据库的表，这不仅增加了数据的冗余， 提高了系统的容错能力，一旦有一个数据库出现问题，从数据库还能够提供服务。 数据库集群 CatMQ的配置元数据以及服务端和消费端的实时对应关系都会实时存储在数据库中，借用业界成熟的的数据库集群的方案，可以进一步提高系统的可用性。 这些设计和实现方式使得 CatMQ 能够实现高可用性和故障转移，并能在面临服务器故障时，仍能维持服务可用。\n"},{"id":5,"href":"/docs/example/design/trace/","title":"链路追踪设计","section":"整体设计","content":" 链路追踪设计 # Tracing # 项目的链路追踪，项目内部内置了美团的cat作为项目的链路追踪服务，catMQ的客户端和服务端支持Cat自动打点，如果自己公司内部也使用了cat的话，只要在pom中引入cat-client即可自动开始打点。 如果不使用cat,也不用担心，只要不引入cat-client,catMQ是不会启动cat-client打点的 或者可以使用Skywalking(may force be with you),使用javaagent 的方式用来监控链路 其他的链路追踪软件出于时间资源的考虑，没有对应测试，欢迎大家提供其他的链路追踪方案\nMetrics # 性能监控上，catMQ自动集成了Metrics，Metrics在项目中，主要用来监控消息的数量，若公司内部有搭建Promethues 的话，只要在pom 中引入micrometer-registry-Influx的依赖，将Metrics 的数据导入即可\n"},{"id":6,"href":"/docs/example/introduce/","title":"项目介绍","section":"CatMQ项目文档","content":" Introduction CatMQ # CatMQ 是一款在参考kafka消息架构基础上发展出来的一款典型的消息队列中间件，使用异步通信的方式和发布订阅模型消息传输队列。 通信方式和传输模型的具体说明可以看下文的通信方式介绍和消息传输模型。 CatMQ具有异步通信的优势，系统拓扑简单，系统间耦合低，主要应用于异步解耦，流量削峰填谷的场景。\n有关CatMQ的功能特性有：\n顺序消息 生产者和消费者的动态缩扩容 消费者和消息队列的动态平衡 支持一个队列被多个消费者组订阅 手动调整消费进度 消息持久化和定期清理 失败消息的保持和重新发送 管理后台网页，可自助运维治理 详细的功能特性介绍可以参考：- 功能特性 "},{"id":7,"href":"/docs/example/quickstart/","title":"快速开始","section":"CatMQ项目文档","content":" 快速开始 # 本页面将简单介绍一下，如何快速的搭建一个单节点的catmq\n(一)环境准备 # Java 本项目基于JDK1.8+ 开发，启动项目的时候会需要JDK1.8+. 配置好Java以后，可以通过java -version检查java环境，样例输出如下 Java -version Java(TM) SE Runtime Environment (build 1.8.0_74-b02) Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode) Maven 需要安装maven3.0，可以去官网下载最新版本的maven, maven 环境变量设置请参考百度谷歌。配置完成后，打开cmd命令，输入mvn -v,显示下图，表示配置完成。 Maven home: D:\\software\\apache-maven-3.6.2\\bin\\.. Java version: 1.8.0_262, vendor: Red Hat, Inc., runtime: D:\\software\\openjdk-1.8.0.262\\jre Default locale: en_US, platform encoding: GBK OS name: \u0026#34;windows 10\u0026#34;, version: \u0026#34;10.0\u0026#34;, arch: \u0026#34;amd64\u0026#34;, family: \u0026#34;windows\u0026#34; MySQL 版本要求5.7+ 连上MySQL以后，可以通过如下命令检查版本 SHOW VARIABLES WHERE Variable_name = 'version'; Variable_name Value version 5.7.0 CatMQ 需要访问字典表information_schema.tables，来获取表的自增信息，来计算待处理消息等信息。所以需要确保此表能及时更新。 对于mysql 8以上版本推荐查看 show variables like \u0026lsquo;%information_schema_stats%\u0026rsquo;; set global information_schema_stats_expiry=10; 设置字典表的更新时间。\n（二）安装步骤 # 在github上，下载代码到本地，以windows 系统为例，下面所有的项目默认目录为d://catmq. 创建数据库 catmq 需要三种消息库，分别为元数据库，正常消息库和失败消息库。 根据doc/mq_basic.sql创建元数据库，元数据库只有一个（可以设置主备）。根据doc/mq_message_node_01.sql创建正常消息库，根据doc/mq_fail_message_node_01.sql文件创建失败消息库。正常消息库和失败消息库都需要多个（可以根据自己的消息量扩容）。下图是创建的数据库样例，包括：元数据库、两个正常消息库、两个失败消息库。 mq_basic mq_suc mq_fail\n配置数据库信息 catmq默认配置了三种环境的配置信息，fat,uat,pro. 当然用户可以自行通过Spring_active添加配置其他的环境的配置。下面的演示中，默认使用fat 环境，用文本编辑工具打开 d:\\catmq\\mq-ui\\src\\main\\resources\\application-fat.properties d:\\catmq\\mq-rest\\src\\main\\resources\\application-fat.properties 将元数据库的信息配置进去 spring.datasource.url = jdbc:mysql://localhost:3306/mq_basic?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false spring.datasource.username = root spring.datasource.password = root 编译运行 在d://catmq 输入mvn clean install -DskipTests 如果控制台显示success, 则证明编译成功。 默认情况portal占用8089端口，服务端占用8080端口，测试demo占用8087端口。 然后进入 d:\\catmq\\mq-rest\\target 目录下执行 java -jar mq-rest.jar \u0026ndash;spring.profiles.active=fat 启动服务端。\nd:\\mq-cat\\mq-ui\\target 目录下执行 java -jar mq-ui.jar \u0026ndash;spring.profiles.active=fat 启动管理端portal。\n注意：测试demo暂时还不能启动（需要等到消息库初始化完成，并且在portal上手动创建测试程序所需的topic、consumerGroup、订阅关系以后可以启动） 5. 启动验证系统。 在chrome浏览器访问 http://localhost:8080/ 如果出现下图表示CatMQ服务端启动正常。 访问 http://localhost:8090/ 如果出现登录页面，并且可以登录成功，则证明可以正常访问，用户名和密码都是：mqadmin (三)元数据的初始化 # 为了能够启动测试，我们需要初始化一些数据\n初始化消息的存储位置\n启动CatMQ的管理页面(CatMQ-ui模块)，通过账号和密码mqadmin登录系统。然后点击左侧的“DataNode” 点击 \u0026ldquo;Create\u0026rdquo; 跳出的数据库详细信息中，分为主库(master)和从库(slave)，如果没有从库可以不填，数据库是我们上文中提到的mq_suc 的连接信息。 注意：如果“”Database”填写的是正常消息库的名字，则“Store Type”需选择normal（如上图标红所示）。如果“”Database”填写的是失败消息库的名字，则“Store Type”需选择Abnormal。\n点击“提交”，如果看到如下记录，则说明message_node_01这一个节点初始化成功。 (四)客户端的demo显示 # 完成上述步骤以后，我们就可以去CatMQ的mq-client-demo模块中启动该模块 messageQueue.xml文件中定义了ConsumerGroup、Topic、以及它们之间的订阅关系（含义：test1sub订阅了topic：test1和test4）。receiverType指定的是每一个topic的消息处理类。\ndemo就是在项目中的模式是CatMQ 的最小可执行的Example,这里我们已经做好了messageQueue.xml的配置，此次您无需做任何修改\n新建topic\n登录系统管理页面Portal,默认为localhost:8090, 初始化的用户名和密码都为：mqadmin。登录进入以后，点击页面左侧的消息主题管理进入如下画面\n点击“创建”按钮，进入topic 创建界面，然后再“topic名称处”输入testtopic\n点击“提交”完成topic的创建。\n新建ConsumerGroup\n在管理界面，点击左侧的消费者组管理，然后点击“创建”按钮，进入consumeGroup创建界面：\n我们创建一个名为testConsumerGroup的consumerGroup\n创建成功之后，可以看到页面以及创建成功 创建订阅关系 建立consumerGroup和topic的关联,点击上一个画面中的subscribe开始订阅\n点击添加订阅，创建订阅关系\n点击确认，订阅成功 启动客户端的demo,运行程序\n进入 \u0026lsquo;cat-mq-client-test\\target\u0026rsquo; 下面执行 ‘java -jar mq-client-test-001-1.0.0.jar \u0026ndash;spring.profiles.active=fat’ 启动客户端demo 进入‘ConsumerGroupConsumer’, 出现下面的数据表示客户端启动成功,已经成功注册到系统中 测试消息的发送和消息的消费\n在浏览器中的网址栏，或者postman中输入下面的URL地址： http://localhost:8087/test1?topicName=testtopic\u0026amp;count=2 这里表示给Topic: testtopic 发送5条消息 在 catmq-client-test的 log 中会看到 下面的信息表示消息的发送和消费都正常。 常见问题 如果应用无法启用，请检查8080，8087，8087 端口是否被占用。\n"},{"id":8,"href":"/docs/example/concept/","title":"基本概念","section":"CatMQ项目文档","content":" 基本概念介绍 # 本页将主要介绍CatMQ 中涉及到的基本概念，以便于用户可以更好的了解本系统\n主题（Topic） # 主题表示某一类消息的聚合，用来区分不同的业务消息，主题和消息是一对多的逻辑，是CatMQ在消息订阅的最小单位。\n在基于主题的系统中，消息被发布到主题或命名通道上。消费者将收到其订阅主题上的所有消息，生产者负责定义订阅者所订阅的消息类别。这是一个基础的概念模型，而在实际的应用中，结构会更复杂。例如为了支持高并发和水平扩展，中间的消息主题需要进行分区，同一个Topic会有多个生产者，同一个信息会有多个消费者，消费者之间要进行负载均衡等。\n消息（Message） # 消息是catmq最小的数据传输单元，生产者将业务数据包装成消息发送到服务端，服务端按照相关语义将消息投递到消费端进行消费。\n消费者组（ConsumerGroup） # 消费者组是一个抽象出来的概念，一个消费者组下面有多个消费者。一个消费者组共同订阅者一个topic。消息会按照设定好的动态算法分配到不同的消费者上，从而提高系统的容错性和可扩展性。\n生产者/消费者（product/consumer） # 生产者负责生产消息，一般由业务方负责生产消息，消息生产者会将消息发送到消息系统的服务端（Broke）。 消费者负责消费信息，一般是下游的业务方，从消费系统服务端拿到消息。\n队列（Queue） # 队列是消息实际存储的地方，也是最小的消息存储单元。catmq 中所有的主题都是由多条队列组合而成。\n消息偏移（MessageQueueOffset） # 消息偏移是记录消息在队列中的位置，由于系统会持久化信息，所以消息消费以后，旧的消息不会消失，系统会自动记录最新的消息消费位置，下一次消息消费的时候，消息就是从这个消费偏移的位置开始消费。\n消息标签(MessageTage) # 消息便签是catmq提供的细粒度的消费分类属性，消费者可以根据MessageType进行更加细粒度的消息控制。\n消息订阅（subscribe） # 消息订阅是消费者获取消息、处理消息的规则和状态配置。消费者订阅一个 topic 后， Topic中的消息都会发送给消费者。\n服务端（Broke） # CatMQ 的基本运行工作单位，是无状态运行，可以轻易的水平扩容，上线下线。\n管理端（Portal） # CatMQ的前端运维管理画面，通过可视化操作，权限控制等功能，方便用户更加简单和直观的运维管理CatMQ 的元数据信息。\n"},{"id":9,"href":"/docs/example/design/","title":"整体设计","section":"CatMQ项目文档","content":" 整体设计 # 小提示：如果你不是很了解分布式队列系统，了解整体设计之前，可以先阅读一下quick start模块，动手实现一个队列 demo，会有助于你更好的了解整体的设计\n1. 消息模型 # 消息的整体模型主要涉及到三个模块\nConsumerGroup表示一些topic的集合，是 CatMQ组织和协调消费者们的一种机制，会被一组消费者订阅，这组消费者会共同消费这个消费者组下面的 topic。\nTopicTopic 是 CatMQ中的消息主题，是一种逻辑概念用来组织和分类消息，没个消息都属于一个特定的主题，而消费者们也会通过订阅这些 topic来接受对应的消息。\nQueueQueue 是 CatMQ 中存储消息的容器，在 CatMQ 中被设计为一张 MySQL的数据表，每个主题可以有多个 Queue, 可以类比为 Kafka 中的partition.\n三种之间的关系如下图所示{width=\u0026ldquo;6.6851859142607175in\u0026rdquo; height=\u0026ldquo;3.8367104111986in\u0026rdquo;}\n2. 架构模块 # 架构模块如下图所示，图中各个模块的说明如下{width=\u0026ldquo;6.8518525809273845in\u0026rdquo; height=\u0026ldquo;3.8025754593175853in\u0026rdquo;}\nBroker\nCatMQ的服务端，主要负责消息的投递，拉取和查询，保证消息的高可用。核心功能如下 a. 提供消息发送接口\nb. 提供消息拉取接口\nc. 提供队列和消费者组的动态重平衡\nd. 元数据的同步\ne. 提供消费偏移的同步\nPortal\nCatMQ的管理界面，主要提供一个CatMQ的可视化管理后台以及作为NameServer,做到Broker 和路由的管理。核心功能如下：\na. ConsumerGroup,topic,Queue的可视化创建和修改\nb. 管理订阅关系\nc. 支持消息查询\nd. 各种审计日志和权限控制\ne. 各种监控报表\nf. 一些监控系统稳定性的定时器\nProducers/Consumers\nCatMQ的生产者/消费者，同属于CatMQ客户端下面，核心功能有\na. 消息同步和异步发送\nb. 消息拉去和消费\nc. 客户端的心跳和偏移的提交\nd. 失败消息重试和发送\nMetadata\nCatMQ的元数据库，用来记录CatMQ所需要的配置信息，核心功能有：\na. 储存consumerGroup,topic 以及订阅关系\nb. 储存数据库的节点信息\nc. 储存Queue,topic,的分配关系\nd. 储存消息偏移\nMessage\nCatMQ的消息数据库，用来持久化所有的消息\n3. E-R图 # DbNode: 记录存储消息的数据库的节点信息，包括 jdbcurl , 用户名，密码\nConsumer：当前系统活跃的消费者\nQueue: 记录 topic 和队列表的实际分配的信息\nQueueOffset: 记录 consumer 和 Queue 的实际对应关系，并且记录他们的消费偏移，（记录某个消费者消费某条 queue的信息）\nTopic: 多个 Queue, 用来存储消息\nConsumerGroup: topic的集合，用来记录系统中的 consumerGroup\nConsumerGroupConsumer: 用来记录系统中的 Consuemr 和 ConsumerGroup 对应的关系\nConsumerGroupTopic: 用来记录 ConsumerGroup 和 Topic 对应的关系{width=\u0026ldquo;5.0in\u0026rdquo; height=\u0026ldquo;3.7in\u0026rdquo;}\n"},{"id":10,"href":"/docs/example/deployment/","title":"运维部属","section":"CatMQ项目文档","content":" 部署文档 # 单机部署 # 单机部署可以参考另一篇文章Quickstart。\n快速开始 分布式部署 # CatMQ 服务端需要部署的两个包是CatMQ-rest （server端）和CatMQ-ui(portal端), 并且server端和portal端都是无状态，并且内部自制了简单 的服务发现功能，所以可以在不搭配其他的分布式组件的形式下使用和发布。 只需要在\\catmq-rest\\src\\main\\resources 和 \\catmq-ui\\src\\main\\resources 下添加对应的环境配置即可，例如添加fat环境， 只需要在上面对应的目录中添加application-fat.properties 文件即可，对应的配置项跟其他环境一样，只是值可能不同。 CatMQ中自制的服务发现功能，将各个server端和portal端的状态信息都存在数据库中，并且每隔5秒钟注册心跳，所以只要server端和portal端成功链接上 数据库即可自动服务发现。这种方案也可以结合Eureka , nginx, nacos 等服务发现的组件。 CatMQ 分布式部署重点在于数据库的集群部署，建议使用主从数据库的方式部署元数据库（1主2从），并且交由infrastructure 运维团队运维。确保元数据 正常使用. 部署的架构图如下所示：\n"},{"id":11,"href":"/docs/example/develop/","title":"开发须知","section":"CatMQ项目文档","content":" CatMQ的开发指南 # 本模块主要介绍项目的代码结构和项目模块，方便打算仔细研究本项目的以及想二次开发的同学做参考\n1. 模块依赖图 # mq-client\\mq-core mq-core 是CatMQ中最基础的模块,里面是最基础的dto对象和公用方法。所有项目的基础 mq-biz biz 是业务逻辑处理层，服务与服务端broke和页面运维端portal，里面是包含数据库实体和很多定时轮询线程。供mq-rest模块和mq-ui模块使用 mq-rest mq-rest是CatMQ的broker服务端，用来对客户端提供rest服务，主要提供消息发送，消息拉取，心跳请求，重平衡。 mq-ui CatMQ的portal界面，提供给外部运维一个可视化的运维界面 mq-client\\mq-client-core 客户端的核心，除了http服务以外，不依赖第三方jar包，封装了客户端的接口 mq-client\\mq-client-spring 对mq-client-core做了spring封装，以便于简化操作，并提供了一些服务统计接口 mq-client\\mq-clent-springboot mq-client-core 的符合springboot 的自动化配置 mq-client-test CatMQ的客户端demo 2. 本地开发环境 # 在application.properties配置文件中默认了spring.profiles.active=fat配置，指定为fat环境。 数据库的连接也在application.properties中，一共有两个模块需要数据库配置连接，分别是mq-rest和mq-ui 3. 本地启动 # 本地启动需要启动两个服务，点击RestApplication的Debug\u0026rsquo;RestApplication\u0026rsquo;,启动mq-rest。点击UiApplication的Debug\u0026rsquo;MqUiApplication\u0026rsquo;, 启动mq-rest。如下图所示： "},{"id":12,"href":"/docs/example/functions/","title":"功能特性","section":"CatMQ项目文档","content":" 功能特性 # 顺序消息 # 顺序消息是CatMQ最所支持的一个消息功能特性，所谓的顺序消息就是一个FIFO模型的消息队列，先发送的消息优先消费。CatMQ可以保证一个ConsumerGroup中的消息是按照顺序消费，如果有消息消费失败，会尝试重试消费失败的消息，如果失败重试达到指定次数，才会消费下一条消息。\n延时消息 # 延时消息是主要为了满足一些延迟消费的场景，延时消息的设置单位为秒。不同的消费者组订阅相同的主题的时候，可以为这些消费者组设置不同的延时时间。\n消费者和队列的负载均衡 # CatMQ允许消费者和实际消息的队列动态的增加或者减少，以应对消费堆积过多或者是多个消费者中有消费者意外宕机的情况。CatMQ会动态的重新匹配消费者和队列的匹配关系。注意，如果当前的消费者的数量大于等于队列的数量，此时再单纯的添加消费者的数量并不会触发重平衡。\n支持一个队列被多个消费者组订阅 # CatMQ支持一个队列被多个消费者组同时订阅，并且消费者组之间对队列的消费互相不影响。比如 A,B 两个消费者组同时订阅了队列 C，不论 B 消费者组发生了什么变更，都不会影响 A 消费者组的消费状态。\n消费进度调整 # CatMQ支持实时动态调整消费者组的消费进度，调整的消费者组的当前消费进度并且实时生效。所有的消费者都会从新的消费偏移开始消费。当然新的消费偏移点必须小于当前的消息队列的最大消费ID, 如果强行设置新的消费位移点大于消息队列的最大ID,会被自动重置为最大ID。\n消息的存储和定时清理 # CatMQ采用的数据库去持久化消息，DB结构的设计可以参考/doc/db 里面的DDL。为了防止冗余数据过多导致的数据溢出，队列在创建的时候，会默认设置一个消息过期时间，到达消息过期时间以后，消息会自动被清除。\n自助式运维治理 # CatMQ拥有一个运维自助治理的管理后台，在这个后台上面可以进行自助式创建和管理所有的Topic,ConsumerGroup, ComsumerOffset的创建和关系管理。支持队列的自助式创建和扩容，支持自助管理ConsumerGroup和Queue的关系管理。\n"},{"id":13,"href":"/docs/example/page/","title":"页面操作","section":"CatMQ项目文档","content":" 一、发送模块 # 1.1、创建消息主题（即topic） # 发送方（producer）发消息到指定Topic之前，需要通过catMQ的portal创建该Topic，如果该Topic已存在则无须创建。下面演示一下如何创建Topic，和创建Topic时的注意事项： 点击最下方的“commit”按钮，完成topic的创建，进入如下页面： 图中可以看到我们刚刚创建的topic：testtopic\n点击每条记录最左侧的蓝色图标，可以查看该topic的操作记录。\n创建topic的注意事项：\nTopic的名字不能以“_fail”结尾，因为系统以“_fail”结尾的Topic默认为存储失败消息的topic。 负责人为该Topic的负责人，可以多选。Topic负责人拥有的权限为： 编辑Topic的基本信息。 更改Topic中存储消息的保留天数。 生成和清除该Topic接收消息时的校验Token，修改Token时需慎重。 对该Topic进行扩容，自动扩容时受限于预期每日消息量。 对该Topic对应所有订阅的消费者产生的失败存储Topic的扩容以及更改保留天数。 删除该Topic，注意当存在消费者订阅该Topic的时候，不能删除。 可以在消息查询中查看该Topic中的消息发送的情况。 堆积告警数默认10000，即当待处理消息达到10000时，会向发生堆积的订阅者 发送消息堆积告警。 二、消费模块 # 2.1、创建消费者组（即consumerGroup） # 在“ConsumeGroup”页面，点击“create”按钮，进入“创建消费者组”页面： 注意事项：\n消费者组名字最好以ConsumerGroup结尾，便于识别。 消费者组负责人可以多选，负责人权限为： 编辑该消费者组的基本信息。 消费者组的订阅管理，主要是添加与topic的订阅关系。 强制刷新，刷新broker中内存的该消费者组的订阅关系，便于客户端获得最新的订阅关系。 删除该消费者组。 触发该消费者组的重平衡（即该消费者组下consumer实例的重新分配）。 告警邮箱地址可以多个以英文逗号分隔，告警手机可以多个以英文逗号分隔。 消费机器数为消费的实例数，即启动的应用实例数，主要为了和消息系统2.0相对应。 黑白名单，为了限制哪些机器不可以消费和只可以哪些机器消费，只能选择其中一个。 是否告警，建议当机器消费实例启动后开启。 消息追踪，主要为了追踪消息在消费者中消费情况。 最大实例数用于设置消费者的最大数量，0表示不加限制。 消费模式：CatMQ有三种消费模式，分别是集群模式、广播模式、代理模式。 集群模式：CatMQ最常用的是集群模式（默认的模式）。consumerGroup订阅的topic下的队列会被均匀的分配到我们的消费端实例上（即多个消费端实例共同消费topic中的消息，每个消费端实例只能消费到topic的一部分消息）。 广播模式：每个消费端实例都可以消费到consumerGroup订阅的topic的所有消息（即consumerGroup下的每个消费端实例，都可以消费到全部的消息。并且每个消费端实例所消费的消息完全一样）。 图中可以看到我们刚刚创建的消费者组：test1sub。\n点击每条记录最左侧的蓝色图标，可以查看该consumerGroup的对应操作功能。\n2.2、消费者组订阅管理（即consumerGroup和topic的订阅关系） # 点击上图消费者组test1sub右侧的“订阅管理”按钮，进入到“TestConsumerGroup订阅管理”页面：\n在上图“主题名称”处选择test1sub想要订阅的topic：test1。选择配置参数后，其中注意事项如下：\n重试次数，作用于失败Topic，当消费失败的时候，消息会被发送到失败topic中，另外一个线程会去消费失败Topic中的消息，即进行失败消息的重试，重新消费成功则pass，否则继续重试直到达到最大重试次数。 线程数量，批量消费的线程数量，即同一个队列使用多少个线程去消费，线程数不能超过50。 告警阀值，当消息堆积达到该值时会发送告警邮件。 tag，值消息的标识，设置tag之后，消费者组只能消费这个Topic下带有该Tag的消息。 延迟时间（即延迟处理时间），以毫秒为单位，主要为了满足一些需要延迟去消费的场景，延迟时间最大为259200ms。 拉取条数，是指每次去向broker拉取多少条消息到客户端去消费，相当于一个本地缓存队列，然后本地线程去消费缓存队列里面的消息，批量拉取条数最大为500。 拉取等待时间，设置拉取线程的延迟等待时间。 消费熔断时间，即客户端处理消息的最大消耗时间。超过设置时间则熔断，单位秒,0表示不熔断。 点击“添加订阅”完成订阅，当前页面下方会显示该消费者组订阅的所有Topic，同时也包含了订阅该Topic所产生的失败Topic，如下如所示： 其中注意事项如下：\n其中失败Topic的命名规则为：ConsumerGroupName_TopicName_fail，当添加订阅的时候会创建该失败Topic并默认分配两个队列。（上图中test1sub_test1_fail就是test1sub订阅test1之后生成的失败topic，用于存储失败消息。） 批量拉取条数和批量消费条数需要加以区分，批量拉取条数是每次向broker拉取的条数（例如一次从broker拉取50条消息存储到本地队列），批量消费条数是指每个线程每次去消费的最大条数（例如：一次从本地队列中拿10条消息，做批量入库操作），故会存在，批量拉取条数\u0026gt;=批量消费条数*线程数量 点击编辑按钮，可以设置该消费者订阅该Topic的重试次数、告警阀值、tag、延迟时间、线程数、批量拉取条数、批量消费条数、告警邮件等 点击“Unsubscribe”，解除消费者组和topic的订阅关系。 一个消费者组可以订阅多个topic，注意失败topic是自动生成的，不用单独订阅。 三、管理模块 # 3.1 堆积统计 # CatMQ的portal，登陆之后默认展示“OverStockReport”页面： “堆积统计”页面，用于统计展示consumerGroup的消息堆积情况。\n3.2 数据统计 # “DataReport”用于展示数据节点（即消息数据库节点）的信息。\n注意：消息库中的一张表代表一个消息队列。上表的信息解读为，节点1是储存正常的消息，现在已经分配出去两个队列，还有198条队列没有分配出去\n3.3 队列消费管理 # “队列消费管理页面”用于展示consumerGroup对topic下每一个队列的消费情况，每一条记录对应着一个队列。\n消费端实例（消费者）成功启动之后，消费端实例会订阅一个或者多个相关队列，参数说明如下：\n消费者：又叫消费端实例，根据重平衡策略，consumerGroup订阅的所有topic下的全部队列，会均匀分配给启动的消费端实例。 偏移量：是指当前队列中的消息，被消费到的位置。消息表（即队列）中的id是自增的，所以偏移量就是刚被消费的那条消息的id值。 待处理消息数：未被处理的消息数量，待处理消息数=队列中消息的最大id-当前偏移量。 读写类型：队列的读写类型分为读写和只读。类型为读写时，该队列既可以插入消息又可以消费消息。类型为只读时，该队列只能消费消息，不能插入。注意：这里需要保证一个Topic下至少存在一个可以读写的队列。点击旁边的白色按钮，即可进行读写类型的编辑。 消费标志：队列的消费标志分为正常消费和停止消费。正常消费顾名思义就是该队列的消息能够被正常消费，停止消费则表示该队列中的消息不能被消费，此时消费端不会去拉该队列中的消息。点击旁边的白色按钮，可以进行消费标志的编辑。 消息总数：队列（消息表）中的消息数量，因为我们会定时清理队列中过期的消息，所以消息总数=队列中消息的最大id-队列中消息的最小id，故会存在偏移量大于消息总数的情况。 起始偏移：是指该消费者组订阅该Topic时，该队列中消息的最大id。即消费者组开始消费消息时的位置。 最小id：该队列（消息表）中消息id最小的记录的id。 Topic类型：正常则为存储普通消息的Topic的队列，失败则为存储失败消息的队列，和存储类型对应。 分区id：该条记录对应的队列的id，可以在队列管理中查询到队列相关的信息。 存储类型：是指该队列的存储类型，一般我们使用失败类型的队列储存失败Topic中的消息，正常类型的队列存储正常类型Topic中的数据。 db节点：表示该队列对应于某个数据库中的某张表，消息都是存储在这个表中的，db节点=数据库的域名+数据库的库名+数据库的表名。 “偏移”按钮：管理员可以通过点击“偏移”按钮，来调整消费者在该队列中的消费位置。实时生效，谨慎操作。 3.4 队列管理 # “队列管理”中的每一条记录，代表着一个队列即一张消息表。\n每个队列对应消息数据库中的一张表，可以通过ip+库名+表名定位到具体的哪张表。\n点击每条记录最左侧的蓝色图标，可以查看该queue的操作记录。\n参数说明：\n队列编号：即该队列在queue表中的id。 数据节点编号：该队列（消息表）所属的数据库节点，在db_node表中的id。 ip: 该队列（消息表）所属数据库节点的域名数据库。 数据库名：该队列（消息表）所属数据库节点的名称。 表名：该队列（消息表）对应的表名称。 库状态：该队列（消息表）所属数据库节点的读写类型。读写表示该数据库既可以插入消息又可以拉取消息，只读表示该数据库只能拉取消息，不能插入。 topic：该队列被用于存储那个topic的消息。该字段为空表示:队列还未被分配。 存储类型：正常表示存储普通消息，失败表示存储处理失败的消息。 读写状态：读写表示该队列既可以插入消息，又可以拉取消息。只读表示该队列只能拉取消息，不能插入。 消息总数：队列（消息表）中的消息数量。 最小id：该队列（消息表）中消息id最小的记录的id。 “编辑”按钮：队列没有被分配时，该记录的最右侧可以看到“编辑”按钮，点击“编辑”可以为该队列分配topic。 “设为只读”：队列被分配给某个topic以后，右侧可以看到“设为只读”。点击该按钮可以把当前队列改为只读状态。 “移除”：队列被分配给某个topic以后，右侧可以看到“移除”。点击“移除”，会进入该topic的缩容页面。 例如点击上图中的“移除”按钮，会进入topic：test1的缩容页面： 例如：上图中topic：testtopic拥有两个队列，如果要对testtopic进行缩容，需要先对其中一个队列设置成只读。假设要缩容掉id为1的队列，步骤如下：\n点击id为1的队列右侧的“只读”按钮，把队列设为只读。 点击1右侧的“移除”按钮，完成test1对9173队列的缩容。 3.5 消息查询 # 消息查询主要用于发送方和消费方查看消息，消息查询中具有权限控制：\n作为发送方只能查看到该用户负责的Topic的消息。 作为消费方只能查看到该用户所负责的消费者组中订阅的Topic里面的消息。 消息查询中可以查看正常类型的Topic的消息，也可以查看失败类型的Topic的消息 对于失败类型的Topic中的消息，如果想重新消费，先选择想要重新消费的消息，然后点击“批量重新发送”按钮，则失败消息会重新发送到失败类型的Topic中，便于该消费者重新消费。 3.6 日志查询 # 日志查询页面，用于展示用户操作portal的审计日志： 3.7 消费者查询 # 消费者查询页面，可以根据consumerGroup查询该consumerGroup下的consumer（即消费端实例）。 消费者查询，主要用来查询该消费者组中启动成功的消费端实例：\n其中消费者实例=ip地址+进程号+随机数+端口号。 消费者实例会定期发送心跳给broker，没有心跳的消息者实例会被定时任务清理掉。 3.8 队列报表 # 队列报表，用于统计每个队列中的消息总量、平均每天的消息发送量。\n图片左下角的“全部消息总量”为所有队列中的消息量的和。同理，“平均消息总量”为所有队列每天存入消息的平均值。\n3.9 topic报表 # topic报表，用于监控统计每个topic下的消息量（每个topic下有多个队列即消息表），以及topic下队列分配的合理性。页面如下图所示：\n字段说明：\n消息总量：该topic下所有队列，存储的消息量总和。 实际每日消息量：该topic每天存入的消息量。 每个队列平均每日消息量：topic下每个队列每天存入的消息量。 队列治理：我们根据topic和topic下每个队列的消息总量以及平均消息量，对topic的队列分配数量进行监控统计，分析队列分配的合理性。如果平均消息量过多，会给出“应该扩容”的建议。如果消息量过少，会给出“应该缩容”的建议。 队列数量治理：队列治理的具体值，例如-1表示应该缩容掉一个队列（即减少一个队列），2表示应该扩容两个队列（即增加两个队列），0表示队列分配合理。 操作区：如果topic需要缩容，右侧会展示“缩容”按钮，点击缩容会进入该topic的缩容页面。同理如果topic需要扩容，右侧会展示“扩容”按钮 3.10 物理机报表 # 物理机报表，用于统计展示每台消息库物理机的消息总量、平均每天入库的消息量。 3.11 发送工具 # 为了方便测试人员，我们开发了一个消息发送页面。通过“Simulation Tools”页面，可以简单的实现消息的发送。 四、系统管理员模块 # 注意：以下页面仅对系统管理员展示。\n4.1 数据节点管理 # 数据节点管理，用于消息库节点的创建、编辑、以及创建消息表与元数据库mq_basic中的queue表的对应关系。\n点击“创建”按钮，弹出创建节点的弹框，创建节点时需要注意：\n主库ip和从库ip不能一样。 读写状态：默认为可读可写，表示数据库可以插入也可以查询。 存储类型：选择“正常队列消息”表示该库用于存储普通消息，选择“失败队列消息”表示该库用于存储处理失败的消息。 “批量对比”按钮，用于为所有库节点的消息表创建与queue的对应关系。\n右侧操作区按钮说明：\n编辑：点击“编辑”按钮，可以修改消息库节点的信息。 生成sql:生成创建表的sql语句。 对比：为当前消息库节点的消息表创建与queue的对应关系。 分析：查看该消息库节点下topic的分布情况。 更改状态：修改当前节点的读写状态。 生成insert：生成插入消息库节点记录的sql语句样例（把节点记录插入db_node库中的语句）。 4.2 通知查询 # 通知查询，用于展示重平衡请求记录的信息（表中的每一条记录表示一个重平衡请求），以及重平衡器当前处理到的位置（即重平衡器处理到了第几条请求）。\n通知查询页面包含两张表，图中蓝色标注的表格记录“重平衡器”当前处理到第几条“重平衡请求”（即重平衡器的处理位点）。图中红色标注的表格记录所有重平衡请求（每一条记录都是一个重平衡请求），记录中的消费者组Id就是触发重平衡的consumerGroup的id。\n4.3 lock # CatMQ中有一些定时器，lock页面用于展示定时器与portal实例的对应关系（定时器会被portal实例抢占执行，如果定时器A被portal实例1抢占了，其他的portal实例则抢占不到定时器A了。）\n上图中ip表示的是portal实例的IP地址，key1表示的是不同定时器的名字，具体含义如下：\nmq_auditlog_clean_sk：操作日志清理定时器。 mq_message_clean_sk：消息清理定时器。 mq_noSubscribe_sk：未订阅检查定时器。 mq_redundance_check_sk：冗余检查定时器。 mq_NoActiveConsumer_sk：服务端心跳异常检测定时器（检测心跳异常的客户端）。 mq_queueExpansion_sk：队列空间检查定时器。 mq_notify_clean_sk：清理重平衡请求和缓存更新请求的定时器。 mq_messageLagN_sk：消息堆积检查定时器。 mq_rb_sk：重平衡检查定时器。 4.4 server # server展示的是broker服务端的实例列表。CatMQ的客户端可以通过两种方式去连接broker服务端，第一种是通过域名的方式（通过nginx）,第二种是通过ip直连的方式（客户端会定时拉取broker服务端实例的ip列表，通过ip地址直接访问）。注意：通过ip直连时，需要在server列表中，把可以被访问的broker服务端实例的statusFlag状态位打开（即允许该broker实例接入流量）。\nCatMQ默认采用ip直连的方式（记得去server列表中打开statusFlag状态位）。CatMQ通过配置的方式来实现域名访问和ip直连方式的切换。具体方式如下：\nCatMQ的客户端和服务端分别有一个配置项，都叫做mq.broker.metaMode。 服务端的mq.broker.metaMode默认值为1，表示强制指定为ip直连的方式（此时客户端的mq.broker.metaMode的配置失效）。 如果服务端的mq.broker.metaMode的值设置为-1，表示强制指定为域名访问的方式（此时客户端的mq.broker.metaMode的配置失效）。 如果服务端的mq.broker.metaMode的值设置为0，表示根据客户端的mq.broker.metaMode配置决定访问方式： 客户端的mq.broker.metaMode值默认为true，表示使用ip直连的访问方式。 如果客户端的mq.broker.metaMode值为false，表示使用域名访问的方式。 注意：只有服务端的mq.broker.metaMode值为0时，客户端的mq.broker.metaMode配置才会生效。\n特表说明：发布时为了防止抖动，需要先将待发布的服务端实例关闭，默认30秒同步到客户端，发布完成打开statusFlag状态位。\n4.5 mysql连接数 # 该页面用于展示CatMQ的元数据库和消息库所在物理机的连接数，如下所示：\n上图中物理机表示的是元数据库和消息库的域名。\n4.6 配置列表 # 配置列表，用于展示配置类soaConfig中所有配置的名称、默认值、当前值、以及配置说明，如下图所示：\n4.7 元数据同步 # 元数据同步页面，用于多个环境之间同步topic、consumerGroup、以及订阅关系（即consumerGroup订阅了那几个topic）。\n具体步骤如下：假设我们要把fat环境的元数据同步到uat环境\n同步topic： 首先进入fat环境的“元数据同步”页面，在“请选择同步类型”处选择“同步topic”。 点击生成按钮，fat的界面上会生产成所有topic的json串，复制生成的json串。 然后进入uat环境的“元数据同步”页面，在“请选择同步类型”处选择“同步topic”。把上一步复制的json串，粘贴到uat的文本区域。 点击uat环境中的“同步”按钮，则开始同步。同步完成时会有提示（由于批量同步量比较大，同步过程需要点时间）。 同步consumerGroup： 首先进入fat环境的“元数据同步”页面，在“请选择同步类型”处选择“同步consumerGroup”。 点击生成按钮，fat的界面上会生产成所有consumerGroup的json串，复制生成的json串。 然后进入uat环境的“元数据同步”页面，在“请选择同步类型”处选择“同步consumerGroup”。把上一步复制的json串，粘贴到uat的文本区域。 点击uat环境中的“同步”按钮，则开始同步。同步完成时会有提示（由于批量同步量比较大，同步过程需要点时间）。 同步订阅关系： 首先进入fat环境的“元数据同步”页面，在“请选择同步类型”处选择“同步订阅关系”。 点击生成按钮，fat的界面上会生产成所有订阅关系的json串，复制生成的json串。 然后进入uat环境的“元数据同步”页面，在“请选择同步类型”处选择“同步订阅关系”。把上一步复制的json串，粘贴到uat的文本区域。 点击uat环境中的“同步”按钮，则开始同步。同步完成时会有提示（由于批量同步量比较大，同步过程需要点时间）。 4.8 Statistic # 队列统计report,可以根据实际数据去统计各个使用部门的消息总量的Report。 "},{"id":14,"href":"/docs/example/hidden/","title":"Hidden","section":"CatMQ项目文档","content":" This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); } Fronde cetera dextrae sequens pennis voce muneris # Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "}]